<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0ea5e9">
  <title>Принципи побудови стегосистем — Конспект | Стеганографія</title>
  <link rel="icon" type="image/svg+xml" href="../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <script>if(localStorage.getItem('theme')==='dark'){document.documentElement.classList.add('dark');}</script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24">
          <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
          <path d="M6 12v5c3 3 9 3 12 0v-5"/>
        </svg>
      </div>
      <div class="logo-text">
        Стеганографія
        <span>онлайн-курс</span>
      </div>
    </div>
    <nav aria-label="Головна навігація">
      <a href="../index.html" class="active">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../practicals.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8"/><path d="M12 17v4"/></svg></span>
        Практичні
      </a>
      <a href="../tests.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../materials.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>
    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <div class="reading-progress">
    <div class="reading-progress-bar"></div>
  </div>

  <main>
    <div class="lecture-nav-top">
      <a href="../lecture.html?id=3" class="back-link">&larr; Назад до лекції 3</a>
      <span class="lecture-badge">Конспект лекції 3</span>
    </div>

    <article class="lecture-content">
      <h1>Принципи побудови стегосистем</h1>

      <div class="konspekt-layout">
        <div class="konspekt-text">
          <div class="konspekt-content">


            <!-- Introduction -->
            <section id="intro">
                <h2>Вступ</h2>

                <p>
                    Побудова надійної стеганографічної системи — це інженерна задача, яка вимагає системного підходу. Як і в будь-якій системі безпеки, недостатньо мати хороший алгоритм — потрібно правильно спроектувати всі компоненти, врахувати загрози, обрати відповідний контейнер та ретельно протестувати результат.
                </p>

                <div class="info-box">
                    <h4>Головне питання проектування</h4>
                    <p>
                        Як побудувати стегосистему, яка буде <strong>надійно приховувати</strong> дані, <strong>ефективно використовувати</strong> ємність контейнера та <strong>протистояти</strong> спробам виявлення — і все це з урахуванням реальних умов експлуатації?
                    </p>
                </div>

                <p>
                    У цій лекції ми розглянемо стегосистему як інженерний об'єкт: визначимо її компоненти та архітектуру, сформулюємо вимоги, пройдемо етапи проектування та обговоримо підходи до тестування.
                </p>
            </section>


            <!-- Architecture -->
            <section id="architecture">
                <h2>1. Архітектура стегосистем</h2>

                <h3>1.1 Компоненти стегосистеми</h3>

                <p>
                    Будь-яка стеганографічна система складається з двох основних підсистем — <strong>вбудовувача</strong> (embedder) та <strong>витягувача</strong> (extractor), які взаємодіють через набір спільних параметрів.
                </p>

                <h4>Підсистема вбудовування (Embedder)</h4>

                <p>Приймає на вхід три компоненти:</p>
                <ul>
                    <li><strong>Контейнер c</strong> — оригінальний носій (зображення, аудіо, відео)</li>
                    <li><strong>Повідомлення m</strong> — дані для приховування (бітова послідовність)</li>
                    <li><strong>Ключ k</strong> — секретний параметр, що визначає спосіб вбудовування</li>
                </ul>
                <p>На виході отримуємо стего-об'єкт s = Emb(c, m, k).</p>

                <h4>Підсистема витягування (Extractor)</h4>

                <p>Приймає на вхід:</p>
                <ul>
                    <li><strong>Стего-об'єкт s</strong> — контейнер з прихованим повідомленням</li>
                    <li><strong>Ключ k</strong> — той самий секретний ключ</li>
                    <li><strong>Контейнер c</strong> (опціонально) — оригінал потрібен лише для non-blind схем</li>
                </ul>
                <p>На виході отримуємо відновлене повідомлення m' = Ext(s, k).</p>

                <div class="warning-box">
                    <h4>Обов'язкова властивість коректності</h4>
                    <p>
                        Для будь-яких допустимих c, m, k має виконуватись: <strong>Ext(Emb(c, m, k), k) = m</strong>.
                        Якщо ця властивість порушується (навіть в одному біті), стегосистема непридатна для використання.
                    </p>
                </div>

                <h3>1.2 Допоміжні модулі</h3>

                <p>Окрім основних підсистем, практична стегосистема зазвичай включає:</p>

                <table class="comparison-table">
                    <tr>
                        <th>Модуль</th>
                        <th>Призначення</th>
                        <th>Приклад</th>
                    </tr>
                    <tr>
                        <td><strong>Препроцесор повідомлення</strong></td>
                        <td>Підготовка даних перед вбудовуванням</td>
                        <td>Шифрування (AES), стиснення (zlib), додавання CRC/хешу для перевірки цілісності</td>
                    </tr>
                    <tr>
                        <td><strong>Аналізатор контейнера</strong></td>
                        <td>Оцінка придатності контейнера</td>
                        <td>Обчислення карти складності зображення, визначення ємності, відбраковка непридатних контейнерів</td>
                    </tr>
                    <tr>
                        <td><strong>Генератор ключів</strong></td>
                        <td>Створення криптографічно стійких ключів</td>
                        <td>CSPRNG (Cryptographically Secure PRNG), деривація з паролю через PBKDF2/Argon2</td>
                    </tr>
                    <tr>
                        <td><strong>Селектор позицій</strong></td>
                        <td>Визначення місць вбудовування</td>
                        <td>Псевдовипадковий вибір пікселів на основі ключа, адаптивний вибір на основі карти складності</td>
                    </tr>
                    <tr>
                        <td><strong>Модуль синхронізації</strong></td>
                        <td>Забезпечення правильного порядку витягування</td>
                        <td>Маркери початку/кінця, заголовок з розміром payload, порядок обходу контейнера</td>
                    </tr>
                </table>

                <h3>1.3 Архітектурні патерни</h3>

                <p>Існує кілька типових архітектур стегосистем, кожна зі своїми перевагами:</p>

                <div class="two-columns">
                    <div>
                        <h4>Заміщувальна (replacement)</h4>
                        <ul>
                            <li>Біти контейнера замінюються бітами повідомлення</li>
                            <li>Приклад: LSB replacement</li>
                            <li>Проста реалізація</li>
                            <li>Вразлива до статистичних атак (пари значень)</li>
                        </ul>
                    </div>
                    <div>
                        <h4>Узгоджувальна (matching)</h4>
                        <ul>
                            <li>Значення контейнера зсуваються до найближчого, що кодує потрібний біт</li>
                            <li>Приклад: LSB matching (±1)</li>
                            <li>Складніша реалізація</li>
                            <li>Зберігає статистичні розподіли</li>
                        </ul>
                    </div>
                </div>

                <div class="two-columns">
                    <div>
                        <h4>Конструктивна (constructive)</h4>
                        <ul>
                            <li>Стего-об'єкт генерується з нуля</li>
                            <li>Приклад: GAN-стеганографія</li>
                            <li>Немає оригінального контейнера</li>
                            <li>Потенційно ідеальна безпека</li>
                        </ul>
                    </div>
                    <div>
                        <h4>Адаптивна (content-adaptive)</h4>
                        <ul>
                            <li>Вбудовування залежить від вмісту контейнера</li>
                            <li>Приклад: HUGO, WOW, S-UNIWARD</li>
                            <li>Мінімізує функцію спотворення</li>
                            <li>Найвища безпека серед модифікуючих методів</li>
                        </ul>
                    </div>
                </div>

                <div class="example-box">
                    <h4>Порівняння replacement vs matching</h4>
                    <p>Нехай піксель має значення 134 (бінарне: 10000110), і нам потрібно вбудувати біт «1».</p>
                    <ul>
                        <li><strong>LSB replacement:</strong> LSB вже дорівнює 0 → замінюємо на 1 → результат 135 (10000111). Значення завжди збільшується при заміні 0→1</li>
                        <li><strong>LSB matching:</strong> LSB дорівнює 0, потрібен 1 → випадково обираємо +1 або −1 → результат 135 або 133. Рівноймовірні обидва напрямки</li>
                    </ul>
                    <p>Різниця критична: replacement створює асиметрію в розподілі значень (пари 2k та 2k+1 вирівнюються), яку легко виявити хі-квадрат тестом. Matching зберігає природний розподіл.</p>
                </div>
            </section>


            <!-- Requirements -->
            <section id="requirements">
                <h2>2. Вимоги до стегосистем</h2>

                <h3>2.1 Функціональні вимоги</h3>

                <p>Функціональні вимоги визначають, <strong>що</strong> система повинна робити:</p>

                <table class="comparison-table">
                    <tr>
                        <th>Вимога</th>
                        <th>Опис</th>
                        <th>Метрика</th>
                    </tr>
                    <tr>
                        <td><strong>Невиявлюваність</strong></td>
                        <td>Стего-об'єкт статистично нерозрізненний від оригінального контейнера</td>
                        <td>KL-дивергенція D(P<sub>c</sub> || P<sub>s</sub>) → 0, помилка детекції → 50% (випадкове вгадування)</td>
                    </tr>
                    <tr>
                        <td><strong>Коректність</strong></td>
                        <td>Витягнуте повідомлення завжди збігається з вбудованим</td>
                        <td>BER = 0 (Bit Error Rate), 100% точне відновлення</td>
                    </tr>
                    <tr>
                        <td><strong>Достатня ємність</strong></td>
                        <td>Можливість приховати необхідний обсяг даних</td>
                        <td>bpp (bits per pixel), bps (bits per sample), відсоток від розміру контейнера</td>
                    </tr>
                    <tr>
                        <td><strong>Безпека</strong></td>
                        <td>Без ключа неможливо виявити чи витягти повідомлення</td>
                        <td>Стійкість ключа: 2<sup>128</sup>+ комбінацій, відсутність бекдорів</td>
                    </tr>
                </table>

                <h3>2.2 Нефункціональні вимоги</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Вимога</th>
                        <th>Опис</th>
                        <th>Приклад обмежень</th>
                    </tr>
                    <tr>
                        <td><strong>Швидкодія</strong></td>
                        <td>Час вбудовування та витягування</td>
                        <td>Реальний час для відеопотоків, &lt;1 сек для зображень</td>
                    </tr>
                    <tr>
                        <td><strong>Сумісність</strong></td>
                        <td>Підтримка стандартних форматів</td>
                        <td>JPEG/PNG для зображень, WAV/MP3 для аудіо, H.264 для відео</td>
                    </tr>
                    <tr>
                        <td><strong>Масштабованість</strong></td>
                        <td>Робота з контейнерами різного розміру</td>
                        <td>Від мініатюри 100×100 до фото 8000×6000 пікселів</td>
                    </tr>
                    <tr>
                        <td><strong>Стійкість до обробки</strong></td>
                        <td>Збереження повідомлення після типових операцій</td>
                        <td>JPEG стиснення (якість 75+), зміна розміру (±10%), обрізка</td>
                    </tr>
                    <tr>
                        <td><strong>Простота інтерфейсу</strong></td>
                        <td>Зручність для кінцевого користувача</td>
                        <td>Мінімум параметрів, автоматичний вибір оптимальних налаштувань</td>
                    </tr>
                </table>

                <h3>2.3 Компроміси між вимогами</h3>

                <p>
                    На практиці неможливо одночасно максимізувати всі характеристики. Проектувальник змушений обирати пріоритети залежно від сценарію використання.
                </p>

                <div class="info-box">
                    <h4>Типові компроміси</h4>
                    <ul>
                        <li><strong>Ємність ↑ → Непомітність ↓</strong> — чим більше даних вбудовуємо, тим більше змінюємо контейнер, тим легше виявити</li>
                        <li><strong>Стійкість ↑ → Непомітність ↓</strong> — стійкі до обробки методи (наприклад, Spread Spectrum) вносять більш помітні зміни</li>
                        <li><strong>Безпека ↑ → Швидкодія ↓</strong> — адаптивні методи з мінімізацією спотворень потребують аналізу всього контейнера</li>
                        <li><strong>Стійкість ↑ → Ємність ↓</strong> — надлишкове кодування для стійкості зменшує корисну ємність</li>
                    </ul>
                </div>

                <div class="example-box">
                    <h4>Приклад: вибір параметрів для різних задач</h4>
                    <table class="comparison-table">
                        <tr>
                            <th>Задача</th>
                            <th>Пріоритет</th>
                            <th>Типовий метод</th>
                        </tr>
                        <tr>
                            <td>Таємна комунікація</td>
                            <td>Непомітність &gt; Ємність &gt; Стійкість</td>
                            <td>S-UNIWARD, адаптивний LSB matching</td>
                        </tr>
                        <tr>
                            <td>Водяний знак (copyright)</td>
                            <td>Стійкість &gt; Непомітність &gt; Ємність</td>
                            <td>Spread Spectrum, QIM у DWT</td>
                        </tr>
                        <tr>
                            <td>Ідентифікація витоку</td>
                            <td>Стійкість &gt; Ємність &gt; Непомітність</td>
                            <td>Forensic watermarking, ECC-кодування</td>
                        </tr>
                        <tr>
                            <td>Передача великих файлів</td>
                            <td>Ємність &gt; Непомітність &gt; Стійкість</td>
                            <td>Multi-bit LSB, k-LSB з ключем</td>
                        </tr>
                    </table>
                </div>
            </section>


            <!-- Methodology -->
            <section id="methodology">
                <h2>3. Методологія проектування</h2>

                <h3>3.1 Етапи розробки стегосистеми</h3>

                <p>Проектування стеганографічної системи складається з шести послідовних етапів:</p>

                <ol>
                    <li>
                        <strong>Аналіз вимог та загроз</strong>
                        <p>Визначення сценарію використання, моделі противника та пріоритетів. Який тип контейнера? Хто противник і які його можливості? Які вимоги до ємності?</p>
                    </li>
                    <li>
                        <strong>Вибір контейнера</strong>
                        <p>Обрання типу та формату носія на основі вимог. Врахування каналу передачі, типових операцій обробки, доступності контейнерів.</p>
                    </li>
                    <li>
                        <strong>Проектування алгоритму</strong>
                        <p>Розробка методу вбудовування та витягування. Вибір домену (просторовий/частотний), стратегії вибору позицій, схеми кодування.</p>
                    </li>
                    <li>
                        <strong>Реалізація ключової системи</strong>
                        <p>Проектування генерації, розподілу та управління ключами. Вибір CSPRNG, протоколу обміну ключами, формату зберігання.</p>
                    </li>
                    <li>
                        <strong>Імплементація та оптимізація</strong>
                        <p>Програмна реалізація з урахуванням швидкодії та безпеки. Захист від атак через побічні канали, безпечне управління пам'яттю.</p>
                    </li>
                    <li>
                        <strong>Тестування та валідація</strong>
                        <p>Перевірка коректності, безпеки та продуктивності. Стегоаналіз власної системи, benchmarking, стрес-тестування.</p>
                    </li>
                </ol>

                <h3>3.2 Вибір контейнера</h3>

                <p>Контейнер — фундамент стегосистеми. Неправильний вибір контейнера зведе нанівець навіть найкращий алгоритм.</p>

                <div class="info-box">
                    <h4>Критерії вибору контейнера</h4>
                    <ul>
                        <li><strong>Надлишковість</strong> — чим більше надлишковості, тим більше «простору» для вбудовування без помітних змін</li>
                        <li><strong>Природність</strong> — контейнер має виглядати типово для контексту передачі (фото з камери, а не згенероване зображення)</li>
                        <li><strong>Поширеність</strong> — формат має бути настільки поширеним, щоб не привертати уваги</li>
                        <li><strong>Формат</strong> — необхідно враховувати особливості стиснення (JPEG руйнує LSB, PNG — ні)</li>
                        <li><strong>Розмір</strong> — більший контейнер = більша ємність + менший embedding rate = менша помітність</li>
                    </ul>
                </div>

                <table class="comparison-table">
                    <tr>
                        <th>Формат</th>
                        <th>Стиснення</th>
                        <th>Придатність для LSB</th>
                        <th>Типова ємність (Full HD)</th>
                    </tr>
                    <tr>
                        <td><strong>BMP</strong></td>
                        <td>Без стиснення</td>
                        <td>Ідеальна</td>
                        <td>~760 КБ (1 bpp, RGB)</td>
                    </tr>
                    <tr>
                        <td><strong>PNG</strong></td>
                        <td>Без втрат (Deflate)</td>
                        <td>Добра</td>
                        <td>~760 КБ (1 bpp, RGB)</td>
                    </tr>
                    <tr>
                        <td><strong>JPEG</strong></td>
                        <td>З втратами (DCT)</td>
                        <td>Погана (руйнує LSB)</td>
                        <td>~50-100 КБ (у DCT-коефіцієнтах)</td>
                    </tr>
                    <tr>
                        <td><strong>WAV</strong></td>
                        <td>Без стиснення (PCM)</td>
                        <td>Добра</td>
                        <td>~5.5 КБ/сек (16 біт, стерео, 1 bps)</td>
                    </tr>
                </table>

                <div class="warning-box">
                    <h4>Типові помилки при виборі контейнера</h4>
                    <ul>
                        <li><strong>Використання BMP для передачі</strong> — формат BMP рідко використовується в Інтернеті, що саме по собі підозріло</li>
                        <li><strong>LSB у JPEG</strong> — JPEG стиснення з втратами знищує LSB; потрібно працювати з DCT-коефіцієнтами</li>
                        <li><strong>Повторне використання контейнера</strong> — якщо противник має доступ до оригіналу, порівняння виявить будь-які зміни</li>
                        <li><strong>Згенеровані контейнери</strong> — штучно створені зображення мають інші статистичні властивості, ніж реальні фото</li>
                    </ul>
                </div>

                <h3>3.3 Генерація та управління ключами</h3>

                <p>
                    Стего-ключ визначає процес вбудовування: які позиції контейнера модифікуються, в якому порядку, з якими параметрами. Безпека ключової системи критична для всієї стегосистеми.
                </p>

                <h4>Вимоги до ключів</h4>

                <ul>
                    <li><strong>Достатня довжина</strong> — мінімум 128 біт для стійкості до brute-force (2<sup>128</sup> ≈ 3.4 × 10<sup>38</sup> варіантів)</li>
                    <li><strong>Криптографічна випадковість</strong> — ключ має бути згенерований CSPRNG (не Math.random()!)</li>
                    <li><strong>Незалежність від контейнера</strong> — ключ не повинен залежати від вмісту контейнера</li>
                    <li><strong>Безпечне зберігання</strong> — ключ не повинен зберігатися разом зі стего-об'єктом</li>
                </ul>

                <h4>Типи ключових систем</h4>

                <table class="comparison-table">
                    <tr>
                        <th>Тип</th>
                        <th>Опис</th>
                        <th>Переваги / Недоліки</th>
                    </tr>
                    <tr>
                        <td><strong>Симетрична</strong></td>
                        <td>Один ключ для вбудовування і витягування</td>
                        <td>Простота / Потрібен безпечний канал для обміну ключем</td>
                    </tr>
                    <tr>
                        <td><strong>Парольна</strong></td>
                        <td>Ключ деривується з паролю через KDF</td>
                        <td>Зручність / Вразливість до словникових атак</td>
                    </tr>
                    <tr>
                        <td><strong>Асиметрична</strong></td>
                        <td>Публічний ключ для вбудовування, приватний для витягування</td>
                        <td>Не потрібен захищений канал / Складність, повільність</td>
                    </tr>
                </table>

                <div class="example-box">
                    <h4>Приклад: деривація ключа з паролю</h4>
                    <p>Використання PBKDF2 для перетворення паролю у стего-ключ:</p>
                    <ol>
                        <li>Користувач вводить пароль: <code>"MySecretPass123"</code></li>
                        <li>Генерується випадкова сіль: <code>salt = random(16 bytes)</code></li>
                        <li>Деривація: <code>key = PBKDF2(password, salt, iterations=100000, keylen=32)</code></li>
                        <li>З key генерується PRNG-послідовність для вибору позицій вбудовування</li>
                    </ol>
                    <p>Сіль зберігається у заголовку стего-об'єкта (це безпечно — без паролю вона марна).</p>
                </div>
            </section>


            <!-- Testing -->
            <section id="testing">
                <h2>4. Тестування та валідація</h2>

                <h3>4.1 Типи тестування</h3>

                <p>Ретельне тестування — обов'язковий етап перед розгортанням стегосистеми. Виділяють чотири основні категорії:</p>

                <table class="comparison-table">
                    <tr>
                        <th>Тип тестування</th>
                        <th>Що перевіряє</th>
                        <th>Методи</th>
                    </tr>
                    <tr>
                        <td><strong>Коректність</strong></td>
                        <td>Точне відновлення повідомлення</td>
                        <td>BER = 0 для всіх тестових пар (контейнер, повідомлення, ключ). Тисячі випадкових тестів</td>
                    </tr>
                    <tr>
                        <td><strong>Якість</strong></td>
                        <td>Візуальна/аудіальна нерозрізненність</td>
                        <td>PSNR &gt; 40 дБ, SSIM &gt; 0.99, SNR &gt; 30 дБ. Суб'єктивна оцінка (MOS)</td>
                    </tr>
                    <tr>
                        <td><strong>Безпека</strong></td>
                        <td>Стійкість до стегоаналізу</td>
                        <td>Хі-квадрат тест, RS-аналіз, SRM/SRNet детектори. Помилка детекції → 50%</td>
                    </tr>
                    <tr>
                        <td><strong>Стійкість</strong></td>
                        <td>Збереження повідомлення після обробки</td>
                        <td>JPEG стиснення, зміна розміру, шум, обрізка, фільтрація</td>
                    </tr>
                </table>

                <h3>4.2 Бенчмаркінг</h3>

                <p>Для об'єктивного порівняння стегосистем використовують стандартні набори даних та методики:</p>

                <div class="info-box">
                    <h4>Стандартні бенчмарки</h4>
                    <ul>
                        <li><strong>BOSSbase</strong> — 10,000 зображень у форматі PGM (512×512), де-факто стандарт для оцінки безпеки стеганографії зображень</li>
                        <li><strong>BOWS-2</strong> — набір зображень для оцінки стійкості водяних знаків</li>
                        <li><strong>StirMark</strong> — інструмент для стрес-тестування стійкості (геометричні атаки, фільтрація)</li>
                        <li><strong>ALASKA</strong> — великий набір (80,000+ зображень) для оцінки сучасних адаптивних методів</li>
                    </ul>
                </div>

                <h3>4.3 Методологія оцінки безпеки</h3>

                <p>Оцінка безпеки стегосистеми проводиться за сценарієм «найгіршого випадку» — припускаємо, що противник:</p>

                <ol>
                    <li>Знає алгоритм вбудовування (принцип Керкгоффса)</li>
                    <li>Має доступ до необмеженої кількості контейнерів та стего-об'єктів</li>
                    <li>Використовує найкращі відомі методи стегоаналізу</li>
                    <li>Має необмежені обчислювальні ресурси (у межах розумного)</li>
                </ol>

                <div class="example-box">
                    <h4>Типовий pipeline оцінки безпеки</h4>
                    <ol>
                        <li><strong>Підготовка:</strong> 5,000 cover-зображень + 5,000 stego-зображень (embedding rate 0.4 bpp)</li>
                        <li><strong>Feature extraction:</strong> SRM (Spatial Rich Model) — 34,671 ознака на зображення</li>
                        <li><strong>Класифікація:</strong> Ensemble classifier (Random Forest), 5-fold cross-validation</li>
                        <li><strong>Метрика:</strong> P<sub>E</sub> = ½(P<sub>FA</sub> + P<sub>MD</sub>) — мінімальна середня помилка детекції</li>
                        <li><strong>Ціль:</strong> P<sub>E</sub> → 0.5 (50% — випадкове вгадування) означає, що стегоаналітик не може відрізнити cover від stego</li>
                    </ol>
                </div>

                <div class="warning-box">
                    <h4>Поширена помилка</h4>
                    <p>
                        Тестування безпеки лише візуально («я не бачу різниці») — це <strong>не</strong> оцінка безпеки. Людське око не здатне виявити статистичні аномалії, які легко знаходять алгоритми стегоаналізу. Завжди тестуйте автоматизованими інструментами.
                    </p>
                </div>
            </section>


            <!-- Practical -->
            <section id="practical">
                <h2>5. Практичні рекомендації</h2>

                <h3>5.1 Чек-лист проектування</h3>

                <div class="info-box">
                    <h4>Перед розгортанням стегосистеми перевірте:</h4>
                    <ol>
                        <li>Коректність витягування підтверджена на 1000+ випадкових тестах (BER = 0)</li>
                        <li>PSNR стего-об'єктів > 40 дБ при цільовому embedding rate</li>
                        <li>Система протестована проти SRM + ensemble classifier (P<sub>E</sub> > 0.4)</li>
                        <li>Ключ генерується CSPRNG, довжина ≥ 128 біт</li>
                        <li>Повідомлення шифрується перед вбудовуванням</li>
                        <li>Контейнери — реальні фото з камери, не згенеровані</li>
                        <li>Embedding rate не перевищує 0.4 bpp для зображень</li>
                        <li>Формат контейнера відповідає контексту передачі</li>
                        <li>Кожен контейнер використовується лише один раз</li>
                        <li>Система стійка до типових операцій обробки (якщо вимагається)</li>
                    </ol>
                </div>

                <h3>5.2 Типові помилки при проектуванні</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Помилка</th>
                        <th>Наслідок</th>
                        <th>Рішення</th>
                    </tr>
                    <tr>
                        <td>Занадто високий embedding rate</td>
                        <td>Легке виявлення стегоаналізом</td>
                        <td>Не перевищувати 0.4 bpp; використовувати більший контейнер</td>
                    </tr>
                    <tr>
                        <td>Детерміновані позиції вбудовування</td>
                        <td>Противник може передбачити модифіковані елементи</td>
                        <td>Псевдовипадковий вибір позицій на основі ключа</td>
                    </tr>
                    <tr>
                        <td>Відсутність шифрування payload</td>
                        <td>Витягнуте повідомлення читабельне без ключа</td>
                        <td>Завжди шифрувати повідомлення (AES-256-GCM)</td>
                    </tr>
                    <tr>
                        <td>Слабкий PRNG</td>
                        <td>Передбачуваний порядок вбудовування</td>
                        <td>Використовувати CSPRNG (ChaCha20, AES-CTR DRBG)</td>
                    </tr>
                    <tr>
                        <td>Відсутність перевірки цілісності</td>
                        <td>Неможливо виявити пошкодження payload</td>
                        <td>Додавати HMAC або CRC-32 до повідомлення</td>
                    </tr>
                    <tr>
                        <td>Ігнорування метаданих</td>
                        <td>EXIF, ICC-профілі можуть видати модифікацію</td>
                        <td>Зберігати оригінальні метадані або видаляти їх з обох (cover і stego)</td>
                    </tr>
                </table>
            </section>


            <!-- Conclusion -->
            <section id="conclusion">
                <h2>Висновки</h2>

                <p>
                    Побудова стеганографічної системи — це системна інженерна задача, що виходить далеко за межі вибору алгоритму вбудовування.
                </p>

                <div class="info-box">
                    <h4>Головне з лекції</h4>
                    <ol>
                        <li><strong>Архітектура</strong> стегосистеми включає embedder, extractor та допоміжні модулі (препроцесор, аналізатор, генератор ключів, селектор позицій)</li>
                        <li><strong>Архітектурні патерни</strong>: replacement, matching, constructive, adaptive — кожен з різним балансом безпеки та складності</li>
                        <li><strong>Вимоги</strong> поділяються на функціональні (невиявлюваність, коректність, ємність, безпека) та нефункціональні (швидкодія, сумісність, масштабованість)</li>
                        <li><strong>Компроміси</strong> неминучі: ємність vs непомітність, стійкість vs ємність, безпека vs швидкодія</li>
                        <li><strong>Проектування</strong> проходить 6 етапів: аналіз вимог → вибір контейнера → алгоритм → ключі → реалізація → тестування</li>
                        <li><strong>Ключова система</strong> має базуватись на CSPRNG з ключами ≥ 128 біт; пароль деривується через PBKDF2/Argon2</li>
                        <li><strong>Тестування</strong> — обов'язкове: коректність (BER=0), якість (PSNR>40дБ), безпека (SRM P<sub>E</sub>>0.4), стійкість</li>
                    </ol>
                </div>

                <p>
                    У наступній лекції ми заглибимось у фундаментальні компроміси стеганографії та дослідимо теоретичні межі того, що можливо досягти.
                </p>
            </section>


          </div>
        </div>

      <aside class="konspekt-sidebar">
        <div class="section-nav">
          <h3>Зміст</h3>
          <ul>
          <li><a href="#intro">Вступ</a></li>
          <li><a href="#architecture">1. Архітектура</a></li>
          <li><a href="#requirements">2. Вимоги</a></li>
          <li><a href="#methodology">3. Методологія проектування</a></li>
          <li><a href="#testing">4. Тестування та валідація</a></li>
          <li><a href="#practical">5. Практичні рекомендації</a></li>
          <li><a href="#conclusion">Висновки</a></li>
          </ul>
        </div>
      </aside>
      </div>
    </article>

    <div class="lecture-nav-bottom">
      <a href="../lecture.html?id=3" class="nav-btn">&larr; До лекції</a>
      <a href="../index.html" class="nav-btn">На головну &rarr;</a>
    </div>

    <footer></footer>
  </main>

  <button class="back-to-top" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">&#8593;</button>

  <script src="../js/main.js"></script>
  <script>
    // Reading Progress Bar
    window.addEventListener('scroll', () => {
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const scrolled = (window.scrollY / docHeight) * 100;
      document.querySelector('.reading-progress-bar').style.width = scrolled + '%';
      const backToTop = document.querySelector('.back-to-top');
      if (window.scrollY > 300) { backToTop.classList.add('show'); }
      else { backToTop.classList.remove('show'); }
    });

    // Active section nav link
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.section-nav a');
    if (navLinks.length > 0) {
      window.addEventListener('scroll', () => {
        let current = '';
        sections.forEach(section => {
          if (scrollY >= section.offsetTop - 200) {
            current = section.getAttribute('id');
          }
        });
        navLinks.forEach(link => {
          link.classList.remove('active');
          if (link.getAttribute('href') === '#' + current) {
            link.classList.add('active');
          }
        });
      });
    }
  </script>
</body>
</html>
