<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції: текстова стеганографія — лінгвістичні та форматні методи приховування.">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Текстова стеганографія — Конспект | Стеганографія</title>
  <link rel="icon" type="image/svg+xml" href="../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <script>if(localStorage.getItem('theme')==='dark'){document.documentElement.classList.add('dark');}</script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24">
          <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
          <path d="M6 12v5c3 3 9 3 12 0v-5"/>
        </svg>
      </div>
      <div class="logo-text">
        Стеганографія
        <span>онлайн-курс</span>
      </div>
    </div>
    <nav aria-label="Головна навігація">
      <a href="../index.html" class="active">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../practicals.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8"/><path d="M12 17v4"/></svg></span>
        Практичні
      </a>
      <a href="../tests.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../materials.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
      <a href="../ctf.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M3 11l18-5v12L3 13v-2z"/><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"/></svg></span>
        CTF
      </a>
    </nav>
    <div class="sidebar-footer">
      <button class="theme-toggle" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <div class="reading-progress">
    <div class="reading-progress-bar"></div>
  </div>

  <main>
    <div class="lecture-nav-top">
      <a href="../lecture.html?id=12" class="back-link">&larr; Назад до лекції 12</a>
      <span class="lecture-badge">Конспект лекції 12</span>
    </div>

    <article class="lecture-content">
      <h1>Текстова стеганографія</h1>

      <div class="konspekt-layout">
        <div class="konspekt-text">
          <div class="konspekt-content">


            <!-- Intro -->
            <section id="intro">
                <h2>Вступ до текстової стеганографії</h2>

                <p>
                    <strong>Текстова стеганографія</strong> — це мистецтво приховування секретної інформації в тексті природної мови так, щоб сам факт існування прихованого повідомлення залишався невиявленим. Це найскладніший вид стеганографії, оскільки текст має найнижчу надлишковість серед усіх типів цифрових носіїв.
                </p>

                <div class="info-box">
                    <h4>Чому текст — складний контейнер?</h4>
                    <p>
                        На відміну від зображень (де зміна одного пікселя на &plusmn;1 непомітна) або аудіо (де LSB семпла нечутний), кожна зміна в тексті потенційно помітна для людини. Текст оперує на рівні <strong>семантики та граматики</strong>, а не числових значень, що робить будь-яку модифікацію значно ризикованішою.
                    </p>
                </div>

                <h3>Порівняння з іншими носіями</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Аспект</th>
                        <th>Зображення</th>
                        <th>Аудіо</th>
                        <th>Відео</th>
                        <th>Текст</th>
                    </tr>
                    <tr>
                        <td><strong>Надлишковість</strong></td>
                        <td>Висока (~2&ndash;4 біт/піксель)</td>
                        <td>Середня (~4 біт/семпл)</td>
                        <td>Дуже висока</td>
                        <td>Дуже низька (~0.5&ndash;2 біт/речення)</td>
                    </tr>
                    <tr>
                        <td><strong>Ємність</strong></td>
                        <td>~1 біт/піксель</td>
                        <td>~1 біт/семпл</td>
                        <td>~кілька біт/кадр</td>
                        <td>~0.5&ndash;2 біт/речення</td>
                    </tr>
                    <tr>
                        <td><strong>Детекція</strong></td>
                        <td>Статистичний аналіз</td>
                        <td>Спектральний аналіз</td>
                        <td>Комбінований</td>
                        <td>Лінгвістичний + статистичний</td>
                    </tr>
                    <tr>
                        <td><strong>Робастність</strong></td>
                        <td>Помірна</td>
                        <td>Добра</td>
                        <td>Помірна</td>
                        <td>Низька&ndash;середня</td>
                    </tr>
                    <tr>
                        <td><strong>Доступність контейнерів</strong></td>
                        <td>Висока</td>
                        <td>Середня</td>
                        <td>Середня</td>
                        <td>Дуже висока</td>
                    </tr>
                </table>

                <h3>Класифікація методів текстової стеганографії</h3>

                <p>Методи текстової стеганографії можна розділити на три великі категорії:</p>

                <ol>
                    <li><strong>Форматні методи</strong> — маніпуляція візуальним представленням тексту (пробіли, Unicode, HTML/CSS) без зміни вмісту</li>
                    <li><strong>Лінгвістичні методи</strong> — зміна слів та структури речень із збереженням значення (синоніми, синтаксичні трансформації)</li>
                    <li><strong>Генеративні методи</strong> — створення нового тексту, що кодує приховане повідомлення (NLG, RNN, LLM)</li>
                </ol>
            </section>


            <!-- Historical -->
            <section id="historical">
                <h2>1. Історичні методи</h2>

                <h3>1.1. Null Cipher (Нуль-шифр)</h3>

                <p>
                    <strong>Null cipher</strong> — стародавня форма стеганографії, де секретне повідомлення закодоване у відкритому тексті за певним правилом. Читач повинен знати правило, щоб відкинути "зайві" символи та виявити повідомлення.
                </p>

                <div class="example-box">
                    <h4>Приклад з Першої світової війни</h4>
                    <p>Повідомлення, перехоплене цензурою:</p>
                    <pre><code>"PRESIDENT'S EMBARGO RULING SHOULD HAVE IMMEDIATE NOTICE."</code></pre>
                    <p>Перші літери кожного слова: <strong>P-E-R-S-H-I-N-G</strong> — ім'я генерала Першинга.</p>
                </div>

                <h4>Типи правил null cipher:</h4>
                <ul>
                    <li><strong>Акростих:</strong> перша літера кожного слова (або рядка)</li>
                    <li><strong>Телестих:</strong> остання літера кожного слова</li>
                    <li><strong>n-та літера:</strong> кожна 3-тя, 5-та тощо літера</li>
                    <li><strong>Перша літера кожного n-го слова:</strong> наприклад, кожного другого</li>
                </ul>

                <div class="warning-box">
                    <h4>Вразливість</h4>
                    <p>
                        Null cipher легко виявляється, якщо текст виглядає неприродно або стилістично дивно. Написання переконливого cover-тексту — основна складність. Під час Другої світової війни німецькі та американські цензори розробили методи виявлення null cipher шляхом аналізу частотних розподілів перших літер слів.
                    </p>
                </div>

                <h3>1.2. Шифр Бекона (1605)</h3>

                <p>
                    <strong>Білітеральний шифр Френсіса Бекона</strong> — один з перших систематичних стеганографічних методів. Кожна літера алфавіту кодується п'ятисимвольною послідовністю з двох символів (A та B):
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Літера</th>
                        <th>Код</th>
                        <th>Літера</th>
                        <th>Код</th>
                        <th>Літера</th>
                        <th>Код</th>
                    </tr>
                    <tr>
                        <td>A</td><td>AAAAA</td>
                        <td>J</td><td>ABAAA</td>
                        <td>S</td><td>BAAAB</td>
                    </tr>
                    <tr>
                        <td>B</td><td>AAAAB</td>
                        <td>K</td><td>ABAAB</td>
                        <td>T</td><td>BAABA</td>
                    </tr>
                    <tr>
                        <td>C</td><td>AAABA</td>
                        <td>L</td><td>ABABA</td>
                        <td>U</td><td>BAABB</td>
                    </tr>
                    <tr>
                        <td>D</td><td>AAABB</td>
                        <td>M</td><td>ABABB</td>
                        <td>W</td><td>BABAA</td>
                    </tr>
                    <tr>
                        <td>E</td><td>AABAA</td>
                        <td>N</td><td>ABBAA</td>
                        <td>X</td><td>BABAB</td>
                    </tr>
                    <tr>
                        <td>F</td><td>AABAB</td>
                        <td>O</td><td>ABBAB</td>
                        <td>Y</td><td>BABBA</td>
                    </tr>
                </table>

                <p>
                    <strong>Стеганографічна реалізація:</strong> A та B кодуються двома візуально різними шрифтами (наприклад, антиква та курсив). Кожна літера секретного повідомлення потребує 5 символів cover-тексту. Це дає ємність 1/5 = 0.2 біт/символ cover-тексту (фактично log<sub>2</sub>(26)/5 &asymp; 0.94 біт на 5 символів).
                </p>

                <div class="formula-box">
                    Довжина cover-тексту = Довжина повідомлення &times; 5
                </div>
            </section>


            <!-- Format Methods -->
            <section id="format-methods">
                <h2>2. Форматні методи</h2>

                <p>
                    Форматні методи змінюють <strong>візуальне представлення</strong> тексту, не торкаючись його вмісту. Це найпростіші методи текстової стеганографії, але вони вразливі до переформатування.
                </p>

                <h3>2.1. Маніпуляція пробілами (Whitespace Steganography)</h3>

                <h4>Trailing spaces (кінцеві пробіли)</h4>
                <p>
                    Додавання невидимих пробілів та табуляцій у кінці рядків тексту. Найпоширеніший варіант:
                </p>

                <ul>
                    <li><strong>Пробіл (U+0020)</strong> = 0</li>
                    <li><strong>Табуляція (U+0009)</strong> = 1</li>
                </ul>

                <div class="example-box">
                    <h4>Приклад: приховання "Hi" (ASCII: 72=01001000, 105=01101001)</h4>
                    <p>Рядок 1: "Hello world" + [пробіл][табуляція][пробіл][пробіл] = біти 0100</p>
                    <p>Рядок 2: "How are you" + [табуляція][пробіл][пробіл][пробіл] = біти 1000</p>
                    <p>Рядок 3: "I am fine" + [пробіл][табуляція][табуляція][пробіл] = біти 0110</p>
                    <p>Рядок 4: "Thanks!" + [табуляція][пробіл][пробіл][табуляція] = біти 1001</p>
                    <p><strong>Результат:</strong> 01001000 01101001 = "Hi"</p>
                </div>

                <h4>Інструмент SNOW (Steganographic Nature of Whitespace)</h4>
                <p>
                    SNOW — популярний інструмент whitespace стеганографії, розроблений Меттью Кваном:
                </p>
                <ul>
                    <li>Додає послідовності до 7 пробілів з табуляціями в кінці рядків</li>
                    <li>Кодує приблизно 3 біти на 8-колонковий табулятор</li>
                    <li>Підтримує ICE шифрування для додаткової безпеки</li>
                    <li>Команди: <code>stegsnow -C -m "Secret" -p "key" input.txt output.txt</code></li>
                </ul>

                <h4>Маніпуляція закінченнями рядків</h4>
                <p>Різні ОС використовують різні закінчення рядків, що можна експлуатувати:</p>
                <ul>
                    <li><strong>Windows:</strong> \r\n (CR+LF) = 0</li>
                    <li><strong>Unix/Linux:</strong> \n (LF) = 1</li>
                </ul>
                <p><strong>Ємність:</strong> 1 біт на рядок тексту.</p>

                <h4>Міжслівні пробіли</h4>
                <p>
                    Варіювання кількості пробілів між словами (1 пробіл = 0, 2 пробіли = 1). У деяких контекстах (виправданий текст, LaTeX) додаткові пробіли виглядають природно.
                </p>

                <div class="warning-box">
                    <h4>Вразливості whitespace методів</h4>
                    <ul>
                        <li>Текстові редактори часто автоматично видаляють trailing spaces</li>
                        <li>Copy-paste зазвичай нормалізує пробіли</li>
                        <li>Email-системи переформатовують текст</li>
                        <li>Git та інші VCS мають опцію strip trailing whitespace</li>
                        <li>Простий скрипт <code>strip()</code> знищує всі приховані дані</li>
                    </ul>
                </div>

                <h3>2.2. Unicode Zero-Width символи</h3>

                <p>
                    Unicode містить кілька символів нульової ширини, які <strong>абсолютно невидимі</strong> при відображенні тексту, але присутні у файлі:
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Символ</th>
                        <th>Код</th>
                        <th>Назва</th>
                        <th>Призначення</th>
                    </tr>
                    <tr>
                        <td>ZWSP</td>
                        <td>U+200B</td>
                        <td>Zero Width Space</td>
                        <td>Позначає можливе місце розриву рядка</td>
                    </tr>
                    <tr>
                        <td>ZWNJ</td>
                        <td>U+200C</td>
                        <td>Zero Width Non-Joiner</td>
                        <td>Запобігає лігатурам в арабських/деванагарі шрифтах</td>
                    </tr>
                    <tr>
                        <td>ZWJ</td>
                        <td>U+200D</td>
                        <td>Zero Width Joiner</td>
                        <td>З'єднання символів (використовується в emoji)</td>
                    </tr>
                    <tr>
                        <td>WJ</td>
                        <td>U+2060</td>
                        <td>Word Joiner</td>
                        <td>Запобігає розриву рядка</td>
                    </tr>
                    <tr>
                        <td>FEFF</td>
                        <td>U+FEFF</td>
                        <td>Zero Width No-Break Space</td>
                        <td>Byte Order Mark (BOM)</td>
                    </tr>
                </table>

                <h4>Схеми кодування</h4>

                <p><strong>2-символьна (1 біт/символ):</strong> ZWSP = 0, ZWNJ = 1</p>
                <p><strong>4-символьна (2 біти/символ):</strong> ZWSP = 00, ZWNJ = 01, ZWJ = 10, WJ = 11</p>

                <div class="example-box">
                    <h4>Приклад: кодування літери "A" (01000001)</h4>
                    <p>При 4-символьній схемі: 01 00 00 01 = ZWNJ ZWSP ZWSP ZWNJ</p>
                    <p>Вставляємо між словами: "Hello[ZWNJ][ZWSP][ZWSP][ZWNJ] world"</p>
                    <p>Візуально: "Hello world" — різниці не видно!</p>
                </div>

                <pre><code>def zwc_encode(message, cover_text):
    binary = ''.join(format(ord(c), '08b') for c in message)
    zwc_map = {'00': '\u200B', '01': '\u200C',
               '10': '\u200D', '11': '\u2060'}
    encoded = ''
    for i in range(0, len(binary), 2):
        pair = binary[i:i+2].ljust(2, '0')
        encoded += zwc_map[pair]
    # Вставляємо після першого пробілу
    idx = cover_text.index(' ')
    return cover_text[:idx] + encoded + cover_text[idx:]

def zwc_decode(stego_text):
    zwc_map = {'\u200B': '00', '\u200C': '01',
               '\u200D': '10', '\u2060': '11'}
    binary = ''
    for char in stego_text:
        if char in zwc_map:
            binary += zwc_map[char]
    # Декодуємо бінарне повідомлення
    message = ''
    for i in range(0, len(binary), 8):
        byte = binary[i:i+8]
        if len(byte) == 8:
            message += chr(int(byte, 2))
    return message</code></pre>

                <div class="info-box">
                    <h4>Переваги та обмеження ZWC</h4>
                    <div class="two-columns">
                        <div>
                            <h4>Переваги</h4>
                            <ul>
                                <li>Повністю невидимі для людини</li>
                                <li>Текст виглядає абсолютно нормально</li>
                                <li>Простота реалізації</li>
                                <li>Висока ємність (не обмежена довжиною тексту)</li>
                            </ul>
                        </div>
                        <div>
                            <h4>Обмеження</h4>
                            <ul>
                                <li>Деякі платформи фільтрують ZWC</li>
                                <li>Легко виявляються пошуком unicode символів</li>
                                <li>Збільшують розмір файлу (3 байти UTF-8/символ)</li>
                                <li>Не підходять для plain ASCII тексту</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <h3>2.3. Гомогліфи (Homoglyph Substitution)</h3>

                <p>
                    <strong>Гомогліфи</strong> — символи Unicode, що виглядають ідентично або майже ідентично, але мають різні коди. Заміна символів на візуально однакові гомогліфи дозволяє кодувати біти:
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Латинський</th>
                        <th>Код</th>
                        <th>Кириличний</th>
                        <th>Код</th>
                        <th>Візуально</th>
                    </tr>
                    <tr><td>a</td><td>U+0061</td><td>а</td><td>U+0430</td><td>Ідентичні</td></tr>
                    <tr><td>e</td><td>U+0065</td><td>е</td><td>U+0435</td><td>Ідентичні</td></tr>
                    <tr><td>o</td><td>U+006F</td><td>о</td><td>U+043E</td><td>Ідентичні</td></tr>
                    <tr><td>p</td><td>U+0070</td><td>р</td><td>U+0440</td><td>Ідентичні</td></tr>
                    <tr><td>c</td><td>U+0063</td><td>с</td><td>U+0441</td><td>Ідентичні</td></tr>
                    <tr><td>x</td><td>U+0078</td><td>х</td><td>U+0445</td><td>Ідентичні</td></tr>
                </table>

                <p>
                    <strong>Ємність:</strong> 1 біт на кожен замінюваний символ. Для англійського тексту ~30&ndash;40% символів мають кириличні гомогліфи. Для кириличного тексту можна використовувати латинські гомогліфи.
                </p>

                <div class="warning-box">
                    <h4>Виявлення гомогліфів</h4>
                    <p>
                        Хоча візуально гомогліфи невідрізнювані, вони тривіально виявляються програмно: перевірка unicode блоку кожного символа виявляє змішування скриптів. Сучасні антифішингові системи також детектують гомогліфи.
                    </p>
                </div>

                <h3>2.4. HTML/CSS стеганографія</h3>

                <p>
                    HTML та CSS надають численні можливості для приховування інформації завдяки гнучкості синтаксису:
                </p>

                <h4>Маніпуляція регістром тегів</h4>
                <p>HTML теги нечутливі до регістру: &lt;HTML&gt; = &lt;html&gt; = &lt;Html&gt;. Кожен тег кодує 1 біт (lowercase = 0, uppercase = 1).</p>

                <h4>Перестановка атрибутів</h4>
                <p>
                    Порядок атрибутів HTML тегів не впливає на відображення. Для тегу з n атрибутами можна закодувати log<sub>2</sub>(n!) біт:
                </p>
                <ul>
                    <li>2 атрибути: log<sub>2</sub>(2!) = 1 біт</li>
                    <li>3 атрибути: log<sub>2</sub>(3!) &asymp; 2.58 біт</li>
                    <li>4 атрибути: log<sub>2</sub>(4!) &asymp; 4.58 біт</li>
                </ul>

                <h4>CSS значення</h4>
                <pre><code>/* Останній біт кольору кодує дані */
.text { color: #000000; }  /* біт 0 */
.text { color: #000001; }  /* біт 1 — візуально ідентично */

/* Надлишкові значення */
.box { margin: 10px 10px 10px 10px; }  /* біт 0 (повна форма) */
.box { margin: 10px; }                  /* біт 1 (скорочена) */

/* Еквівалентні одиниці */
.box { width: 100px; }    /* біт 0 */
.box { width: 75pt; }     /* біт 1 — ~100px */</code></pre>

                <div class="info-box">
                    <h4>Переваги HTML/CSS стеганографії</h4>
                    <p>
                        HTML стеганографія стійкіша за whitespace методи, оскільки браузери зберігають структуру HTML при рендерингу. Веб-сторінки — природне середовище для передачі, що не викликає підозр. Ємність може бути значною для складних веб-сторінок з багатьма тегами та CSS правилами.
                    </p>
                </div>
            </section>


            <!-- Linguistic Methods -->
            <section id="linguistic">
                <h2>3. Лінгвістичні методи</h2>

                <p>
                    Лінгвістичні методи змінюють <strong>слова та структуру</strong> тексту, зберігаючи його значення. Вони значно робастніші за форматні методи (стійкі до переформатування), але складніші в реалізації та потребують NLP інструментів.
                </p>

                <h3>3.1. Заміна синонімів (Synonym Substitution)</h3>

                <p>
                    Основна ідея: для кожного слова, що має синоніми, вибір конкретного синоніму кодує один або кілька бітів:
                </p>

                <div class="example-box">
                    <h4>Приклади пар синонімів (1 біт кожна)</h4>
                    <table class="comparison-table">
                        <tr><th>Біт 0</th><th>Біт 1</th><th>Контекст</th></tr>
                        <tr><td>big</td><td>large</td><td>Розмір об'єкта</td></tr>
                        <tr><td>fast</td><td>quick</td><td>Швидкість</td></tr>
                        <tr><td>happy</td><td>glad</td><td>Емоція</td></tr>
                        <tr><td>start</td><td>begin</td><td>Початок дії</td></tr>
                        <tr><td>buy</td><td>purchase</td><td>Придбання</td></tr>
                    </table>
                </div>

                <h4>Алгоритм вершинного кодування (Chang &amp; Clark, 2014)</h4>

                <ol>
                    <li><strong>Побудова словника:</strong> для кожного слова тексту знайти множину синонімів (WordNet, тезаурус)</li>
                    <li><strong>Фільтрація:</strong> залишити лише контекстно-сумісні синоніми (за POS-тегом, колокаціями)</li>
                    <li><strong>Кодування:</strong> кожній множині синонімів призначити бінарні коди (T-Lex кодування)</li>
                    <li><strong>Заміна:</strong> замінити слова відповідно до бітів секретного повідомлення</li>
                </ol>

                <div class="formula-box">
                    Ємність &asymp; 0.5&ndash;1.0 біт на речення (в середньому 1 замінюване слово на 1&ndash;2 речення)
                </div>

                <div class="warning-box">
                    <h4>Складнощі синонімічних методів</h4>
                    <ul>
                        <li><strong>Контекстна залежність:</strong> "bright student" &ne; "luminous student"</li>
                        <li><strong>Колокації:</strong> "heavy rain" не замінюється на "weighty rain"</li>
                        <li><strong>Стилістичні відмінності:</strong> "purchase" формальніше за "buy"</li>
                        <li><strong>Зміна статистики:</strong> частотний розподіл слів стає аномальним</li>
                        <li><strong>Обмеженість тезаурусів:</strong> WordNet покриває не всі контексти</li>
                    </ul>
                </div>

                <h3>3.2. Синтаксичні трансформації</h3>

                <p>
                    Маніпуляція граматичною структурою речення зі збереженням семантики. Кожна трансформація кодує 1 біт (оригінал = 0, трансформація = 1):
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Трансформація</th>
                        <th>Оригінал (біт 0)</th>
                        <th>Трансформація (біт 1)</th>
                    </tr>
                    <tr>
                        <td>Актив &harr; Пасив</td>
                        <td>"Кіт зловив мишу"</td>
                        <td>"Миша була зловлена котом"</td>
                    </tr>
                    <tr>
                        <td>Cleft-речення</td>
                        <td>"Іван з'їв торт"</td>
                        <td>"Це Іван з'їв торт"</td>
                    </tr>
                    <tr>
                        <td>Порядок прикметників</td>
                        <td>"гарний великий будинок"</td>
                        <td>"великий гарний будинок"</td>
                    </tr>
                    <tr>
                        <td>Прямий &harr; Непрямий порядок</td>
                        <td>"Він сказав: «Я прийду»"</td>
                        <td>"Він сказав, що прийде"</td>
                    </tr>
                    <tr>
                        <td>Перестановка підрядних</td>
                        <td>"Коли прийшов, побачив"</td>
                        <td>"Побачив, коли прийшов"</td>
                    </tr>
                </table>

                <p><strong>Ємність:</strong> 0.5&ndash;1.0 біт на речення (не кожне речення допускає трансформацію).</p>

                <div class="info-box">
                    <h4>Переваги синтаксичних трансформацій</h4>
                    <p>
                        На відміну від синонімів, синтаксичні трансформації <strong>стійкі до парафразування</strong> (текст можна переписати іншими словами, але структурна трансформація залишиться). Вони також не змінюють частотний розподіл слів, що ускладнює статистичне виявлення.
                    </p>
                </div>

                <h3>3.3. Семантичні методи</h3>

                <p>
                    Найскладніший рівень — маніпуляція значенням на концептуальному рівні:
                </p>

                <ul>
                    <li><strong>Генерація парафраз:</strong> повне перефразування речення з іншою структурою</li>
                    <li><strong>Переупорядкування інформації:</strong> зміна порядку фактів у тексті</li>
                    <li><strong>Модифікація дискурсу:</strong> зміна зв'язків між реченнями (причина-наслідок, контраст, деталізація)</li>
                    <li><strong>Контрольована генерація:</strong> створення тексту з заданими семантичними обмеженнями</li>
                </ul>

                <p>
                    Семантичні методи теоретично найбезпечніші, але практично складні в автоматичній реалізації. Сучасні LLM відкривають нові можливості в цьому напрямку.
                </p>
            </section>


            <!-- Neural/NLG -->
            <section id="neural">
                <h2>4. Генеративні методи (NLG та LLM)</h2>

                <p>
                    Генеративні методи створюють <strong>новий текст</strong>, який одночасно є зв'язним cover-текстом та кодує секретне повідомлення. Це найперспективніший напрям текстової стеганографії.
                </p>

                <h3>4.1. RNN-Stega</h3>

                <p>
                    <strong>Архітектура:</strong> рекурентна нейронна мережа (LSTM/GRU), навчена на великому текстовому корпусі, генерує текст поточено — слово за словом.
                </p>

                <h4>Принцип вбудовування:</h4>
                <ol>
                    <li>На кожному кроці генерації модель видає розподіл ймовірностей P(w<sub>t</sub> | w<sub>1</sub>,...,w<sub>t&minus;1</sub>) по всьому словнику</li>
                    <li>Відсортувати top-K кандидатів за ймовірністю</li>
                    <li>Використати біти секретного повідомлення для вибору серед кандидатів</li>
                    <li>Обраний токен стає наступним словом тексту та подається на вхід для генерації наступного</li>
                </ol>

                <div class="formula-box">
                    Кількість вбудованих бітів на токен = log<sub>2</sub>(K)
                    <br><br>
                    де K — кількість кандидатів на кожному кроці
                </div>

                <div class="example-box">
                    <h4>Приклад: вбудовування з top-4 кандидатами</h4>
                    <p>Модель згенерувала контекст "The weather is".</p>
                    <p>Top-4 кандидати: [nice (0.35), good (0.25), bad (0.20), great (0.15)]</p>
                    <p>Секретні біти: "10" &rarr; обираємо 3-й кандидат (bad, індекс 10<sub>2</sub>)</p>
                    <p>Результат: "The weather is bad..."</p>
                    <p><strong>Ємність:</strong> log<sub>2</sub>(4) = 2 біти на токен</p>
                </div>

                <h3>4.2. Adaptive Dynamic Grouping (ADG)</h3>

                <p>
                    ADG (Yang et al., 2019) — вдосконалений метод, що адаптивно розбиває словник на групи рівної ймовірності:
                </p>

                <ol>
                    <li>На кожному кроці отримати розподіл P(w<sub>t</sub>) по словнику</li>
                    <li>Динамічно розбити словник на 2<sup>r</sup> груп, де кожна група має приблизно рівну сумарну ймовірність</li>
                    <li>Секретні r біт визначають номер групи</li>
                    <li>Обрати конкретне слово з вибраної групи за нормалізованим розподілом</li>
                </ol>

                <div class="info-box">
                    <h4>Безпека ADG</h4>
                    <p>
                        ADG забезпечує <strong>доказово низьку KL-дивергенцію</strong> між розподілом згенерованого тексту та природним текстом моделі. Оскільки слово обирається пропорційно до своєї ймовірності в мовній моделі, статистичні характеристики стего-тексту наближаються до характеристик природного тексту.
                    </p>
                </div>

                <h3>4.3. LLM-based стеганографія</h3>

                <p>
                    Сучасні великі мовні моделі (GPT, Claude, LLaMA) відкривають нові можливості для текстової стеганографії. Основні підходи:
                </p>

                <h4>White-box (доступ до логітів)</h4>
                <p>
                    Якщо є доступ до розподілу ймовірностей моделі (логітів), можна застосувати ті ж методи, що й для RNN-Stega/ADG, але з набагато якіснішою мовною моделлю. Генерований текст майже невідрізнювальний від людського.
                </p>

                <h4>Black-box (тільки API)</h4>
                <p>
                    <strong>LLM-Stega</strong> (2024) для black-box API:
                </p>
                <ol>
                    <li><strong>Побудова ключових слів:</strong> секретне повідомлення перетворюється на набір ключових слів через криптографічне відображення</li>
                    <li><strong>Формування промпту:</strong> ключові слова вбудовуються в промпт для LLM ("Напиши параграф, використовуючи слова: ...")</li>
                    <li><strong>Генерація cover-тексту:</strong> LLM генерує природний текст, що містить ключові слова</li>
                    <li><strong>Витягування:</strong> з отриманого тексту витягаються ключові слова, з них відновлюється повідомлення</li>
                </ol>

                <div class="info-box">
                    <h4>Ключова перевага LLM-Stega</h4>
                    <p>
                        Працює з будь-якими LLM через публічний API без потреби в доступі до ваг моделі. Згенерований текст виглядає абсолютно природно, оскільки створюється повноцінною мовною моделлю.
                    </p>
                </div>

                <h3>4.4. Порівняння генеративних методів</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Метод</th>
                        <th>Модель</th>
                        <th>Ємність</th>
                        <th>Якість тексту</th>
                        <th>Безпека</th>
                    </tr>
                    <tr>
                        <td>RNN-Stega</td>
                        <td>LSTM/GRU</td>
                        <td>1&ndash;3 біт/токен</td>
                        <td>Середня</td>
                        <td>Середня</td>
                    </tr>
                    <tr>
                        <td>ADG</td>
                        <td>LSTM/GPT-2</td>
                        <td>Адаптивна</td>
                        <td>Добра</td>
                        <td>Висока (доказова)</td>
                    </tr>
                    <tr>
                        <td>White-box LLM</td>
                        <td>GPT-3/4, LLaMA</td>
                        <td>1&ndash;4 біт/токен</td>
                        <td>Дуже висока</td>
                        <td>Дуже висока</td>
                    </tr>
                    <tr>
                        <td>LLM-Stega (black-box)</td>
                        <td>Будь-який LLM API</td>
                        <td>~5&ndash;20 біт/запит</td>
                        <td>Дуже висока</td>
                        <td>Висока</td>
                    </tr>
                </table>
            </section>


            <!-- Steganalysis -->
            <section id="steganalysis">
                <h2>5. Стегоаналіз тексту</h2>

                <h3>5.1. Виявлення форматних методів</h3>

                <h4>Whitespace стеганографія:</h4>
                <pre><code>def detect_whitespace_stego(text):
    lines = text.split('\n')
    trailing = [len(line) - len(line.rstrip()) for line in lines]
    avg = sum(trailing) / max(len(trailing), 1)
    variance = sum((x - avg)**2 for x in trailing) / max(len(trailing), 1)
    if avg > 2 or variance > 8:
        return f"Підозріло: avg trailing={avg:.1f}, var={variance:.1f}"
    return "Чисто"</code></pre>

                <h4>Zero-width символи:</h4>
                <pre><code>import re

def detect_zwc(text):
    pattern = r'[\u200B\u200C\u200D\u2060\uFEFF]'
    matches = re.findall(pattern, text)
    if matches:
        return f"Виявлено {len(matches)} zero-width символів"
    return "Zero-width символи не знайдено"</code></pre>

                <h4>Гомогліфи:</h4>
                <pre><code>import unicodedata

def detect_homoglyphs(text):
    scripts = set()
    for char in text:
        if char.isalpha():
            script = unicodedata.name(char, '').split()[0]
            scripts.add(script)
    if len(scripts) > 1:
        return f"Змішування скриптів: {scripts}"
    return "Однорідний скрипт"</code></pre>

                <h3>5.2. Статистичний аналіз тексту</h3>

                <h4>Перплексія (Perplexity)</h4>

                <p>
                    Перплексія вимірює, наскільки "здивована" мовна модель текстом. Стего-текст, де слова обрані не за найвищою ймовірністю, матиме <strong>вищу перплексію</strong>:
                </p>

                <div class="formula-box">
                    PP = exp(&minus;(1/N) &sum;<sub>i=1</sub><sup>N</sup> log P(w<sub>i</sub> | w<sub>1</sub>,...,w<sub>i&minus;1</sub>))
                </div>

                <p>
                    <strong>Інтерпретація:</strong> PP &asymp; 20 для якісного людського тексту; PP &gt; 50 може вказувати на стеганографію або низькоякісну генерацію.
                </p>

                <h4>Feature вектори для ML детекції</h4>
                <ol>
                    <li><strong>Лексичні:</strong> розподіл частот слів, TTR (Type-Token Ratio), лексична різноманітність</li>
                    <li><strong>Синтаксичні:</strong> розподіл POS-тегів, глибина дерева розбору, n-gram статистики</li>
                    <li><strong>Стилістичні:</strong> середня довжина речення, варіація довжини, патерни пунктуації</li>
                    <li><strong>Семантичні:</strong> когерентність (BLEU, BERTScore), тематична консистентність</li>
                    <li><strong>Статистичні:</strong> ентропія тексту, розподіл рідкісних слів, коефіцієнт Ципфа</li>
                </ol>

                <h3>5.3. ML/DL детектори</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Архітектура</th>
                        <th>Принцип</th>
                        <th>Ефективність</th>
                        <th>Проти яких методів</th>
                    </tr>
                    <tr>
                        <td><strong>CNN-based</strong></td>
                        <td>Згорткові фільтри на word embeddings</td>
                        <td>Добра</td>
                        <td>Синонімічна заміна</td>
                    </tr>
                    <tr>
                        <td><strong>BiLSTM + Attention</strong></td>
                        <td>Двонаправлений LSTM з механізмом уваги</td>
                        <td>Висока</td>
                        <td>NLG стеганографія</td>
                    </tr>
                    <tr>
                        <td><strong>BERT-based</strong></td>
                        <td>Fine-tuned BERT для класифікації cover/stego</td>
                        <td>Дуже висока</td>
                        <td>Більшість методів</td>
                    </tr>
                    <tr>
                        <td><strong>GPT-based детектори</strong></td>
                        <td>Аналіз перплексії та ймовірностей токенів</td>
                        <td>Висока для LLM-stego</td>
                        <td>Генеративні методи</td>
                    </tr>
                </table>

                <h3>5.4. Метрики якості детекції</h3>

                <div class="formula-box">
                    Accuracy = (TP + TN) / (TP + TN + FP + FN)
                    <br><br>
                    Precision = TP / (TP + FP) &mdash; точність
                    <br><br>
                    Recall = TP / (TP + FN) &mdash; повнота
                    <br><br>
                    F1 = 2 &middot; Precision &middot; Recall / (Precision + Recall)
                </div>

                <p>де TP = вірно виявлена стеганографія, TN = вірно визначений чистий текст, FP = хибне спрацювання, FN = пропущена стеганографія.</p>
            </section>


            <!-- Tools -->
            <section id="tools">
                <h2>6. Інструменти та практичні застосування</h2>

                <h3>6.1. Інструменти текстової стеганографії</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Інструмент</th>
                        <th>Тип</th>
                        <th>Метод</th>
                        <th>Платформа</th>
                    </tr>
                    <tr>
                        <td><strong>Snow/Stegsnow</strong></td>
                        <td>Whitespace</td>
                        <td>Tabs/spaces в кінці рядків + ICE шифрування</td>
                        <td>Linux/Windows CLI</td>
                    </tr>
                    <tr>
                        <td><strong>Spam Mimic</strong></td>
                        <td>Генеративний</td>
                        <td>Null cipher у формі спам-листа</td>
                        <td>Web</td>
                    </tr>
                    <tr>
                        <td><strong>Unicode Steganography</strong></td>
                        <td>ZWC</td>
                        <td>Zero-width символи між словами</td>
                        <td>Web, JavaScript</td>
                    </tr>
                    <tr>
                        <td><strong>TextStego (Python)</strong></td>
                        <td>NLG</td>
                        <td>RNN/GPT-2 генеративна стеганографія</td>
                        <td>Python, PyTorch</td>
                    </tr>
                    <tr>
                        <td><strong>StegaText</strong></td>
                        <td>Синоніми</td>
                        <td>WordNet-based синонімічна заміна</td>
                        <td>Java</td>
                    </tr>
                </table>

                <h3>6.2. Практичні застосування</h3>

                <div class="two-columns">
                    <div>
                        <h4>Легітимні використання</h4>
                        <ul>
                            <li><strong>Захист авторських прав:</strong> невидимі водяні знаки в документах для доведення авторства</li>
                            <li><strong>Відстеження витоків:</strong> кожна копія документа містить унікальний ідентифікатор отримувача</li>
                            <li><strong>Автентифікація:</strong> перевірка цілісності документа через приховані контрольні суми</li>
                            <li><strong>Обхід цензури:</strong> передача інформації в умовах обмеженого доступу</li>
                        </ul>
                    </div>
                    <div>
                        <h4>Загрози безпеці</h4>
                        <ul>
                            <li><strong>Ексфільтрація даних:</strong> приховання секретних даних у звичайному тексті</li>
                            <li><strong>C2 комунікація:</strong> управління шкідливим ПЗ через public тексти</li>
                            <li><strong>Фішинг:</strong> гомогліфні атаки на доменні імена (punycode)</li>
                            <li><strong>Обхід DLP:</strong> приховання конфіденційних даних від систем запобігання витоків</li>
                        </ul>
                    </div>
                </div>
            </section>


            <!-- Conclusion -->
            <section id="conclusion">
                <h2>Висновки</h2>

                <h3>Порівняння всіх методів</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Метод</th>
                        <th>Ємність</th>
                        <th>Непомітність</th>
                        <th>Безпека</th>
                        <th>Робастність</th>
                        <th>Складність</th>
                    </tr>
                    <tr>
                        <td>Whitespace</td>
                        <td>Низька</td>
                        <td>Висока</td>
                        <td>Низька</td>
                        <td>Дуже низька</td>
                        <td>Проста</td>
                    </tr>
                    <tr>
                        <td>Unicode ZWC</td>
                        <td>Середня</td>
                        <td>Дуже висока</td>
                        <td>Середня</td>
                        <td>Низька</td>
                        <td>Проста</td>
                    </tr>
                    <tr>
                        <td>Гомогліфи</td>
                        <td>Середня</td>
                        <td>Дуже висока</td>
                        <td>Низька</td>
                        <td>Середня</td>
                        <td>Проста</td>
                    </tr>
                    <tr>
                        <td>HTML/CSS</td>
                        <td>Середня</td>
                        <td>Висока</td>
                        <td>Середня</td>
                        <td>Середня</td>
                        <td>Середня</td>
                    </tr>
                    <tr>
                        <td>Синоніми</td>
                        <td>Низька</td>
                        <td>Середня</td>
                        <td>Середня</td>
                        <td>Висока</td>
                        <td>Висока</td>
                    </tr>
                    <tr>
                        <td>Синтаксис</td>
                        <td>Дуже низька</td>
                        <td>Висока</td>
                        <td>Висока</td>
                        <td>Висока</td>
                        <td>Висока</td>
                    </tr>
                    <tr>
                        <td>NLG/LLM</td>
                        <td>Середня&ndash;Висока</td>
                        <td>Дуже висока</td>
                        <td>Дуже висока</td>
                        <td>Низька</td>
                        <td>Дуже висока</td>
                    </tr>
                </table>

                <h3>Ключові висновки</h3>

                <div class="info-box">
                    <ul>
                        <li><strong>Текстова стеганографія</strong> — найскладніший вид через мінімальну надлишковість тексту як носія</li>
                        <li><strong>Форматні методи</strong> (whitespace, ZWC, гомогліфи) — прості, але вразливі до переформатування та тривіально детектуються програмно</li>
                        <li><strong>Лінгвістичні методи</strong> (синоніми, синтаксичні трансформації) — робастніші, але потребують NLP та мають низьку ємність</li>
                        <li><strong>Генеративні методи</strong> (NLG, LLM) — найперспективніший напрям; LLM-based стеганографія дає текст, практично невідрізнювальний від людського</li>
                        <li><strong>Стегоаналіз</strong> активно розвивається: BERT-based детектори досягають високої точності, але гонка озброєнь між стеганографією та стегоаналізом продовжується</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>Що далі?</h4>
                    <p>
                        У наступних лекціях ми розглянемо <strong>машинне навчання в стеганографії</strong> — GAN-based генерацію стего-контейнерів, нейронні стегоаналітики та сучасні тренди на перетині AI та інформаційної безпеки.
                    </p>
                </div>
            </section>


          </div>
        </div>
      <aside class="konspekt-sidebar">
        <div class="section-nav">
          <h4>Зміст</h4>
          <ul>
          <li><a href="#intro">Вступ</a></li>
          <li><a href="#historical">1. Історичні методи</a></li>
          <li><a href="#format-methods">2. Форматні методи</a></li>
          <li><a href="#linguistic">3. Лінгвістичні методи</a></li>
          <li><a href="#neural">4. Генеративні методи</a></li>
          <li><a href="#steganalysis">5. Стегоаналіз</a></li>
          <li><a href="#tools">6. Інструменти</a></li>
          <li><a href="#conclusion">Висновки</a></li>
          </ul>
        </div>
      </aside>
      </div>
    </article>

    <div class="lecture-nav-bottom">
      <a href="../lecture.html?id=12" class="nav-btn">&larr; До лекції</a>
      <a href="../index.html" class="nav-btn">На головну &rarr;</a>
    </div>

    <footer></footer>
  </main>

  <button class="back-to-top">&#8593;</button>

  <script src="../js/main.js"></script>
  <script>
    // Reading Progress Bar
    window.addEventListener('scroll', () => {
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const scrolled = (window.scrollY / docHeight) * 100;
      document.querySelector('.reading-progress-bar').style.width = scrolled + '%';
      const backToTop = document.querySelector('.back-to-top');
      if (window.scrollY > 300) { backToTop.classList.add('show'); }
      else { backToTop.classList.remove('show'); }
    });

    // Active section nav link
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.section-nav a');
    if (navLinks.length > 0) {
      window.addEventListener('scroll', () => {
        let current = '';
        sections.forEach(section => {
          if (scrollY >= section.offsetTop - 200) {
            current = section.getAttribute('id');
          }
        });
        navLinks.forEach(link => {
          link.classList.remove('active');
          if (link.getAttribute('href') === '#' + current) {
            link.classList.add('active');
          }
        });
      });
    }
  </script>
</body>
</html>
