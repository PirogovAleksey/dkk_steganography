<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції: частотні методи стеганографії — DCT, DWT, розширення спектру.">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Частотні методи стеганографії — Конспект | Стеганографія</title>
  <link rel="icon" type="image/svg+xml" href="../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <script>if(localStorage.getItem('theme')==='dark'){document.documentElement.classList.add('dark');}</script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24">
          <path d="M22 10v6M2 10l10-5 10 5-10 5z"/>
          <path d="M6 12v5c3 3 9 3 12 0v-5"/>
        </svg>
      </div>
      <div class="logo-text">
        Стеганографія
        <span>онлайн-курс</span>
      </div>
    </div>
    <nav aria-label="Головна навігація">
      <a href="../index.html" class="active">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../practicals.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2"/><path d="M8 21h8"/><path d="M12 17v4"/></svg></span>
        Практичні
      </a>
      <a href="../tests.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../materials.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
      <a href="../ctf.html">
        <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M3 11l18-5v12L3 13v-2z"/><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"/></svg></span>
        CTF
      </a>
    </nav>
    <div class="sidebar-footer">
      <button class="theme-toggle" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <div class="reading-progress">
    <div class="reading-progress-bar"></div>
  </div>

  <main>
    <div class="lecture-nav-top">
      <a href="../lecture.html?id=6" class="back-link">&larr; Назад до лекції 6</a>
      <span class="lecture-badge">Конспект лекції 6</span>
    </div>

    <article class="lecture-content">
      <h1>Частотні методи стеганографії</h1>

      <div class="konspekt-layout">
        <div class="konspekt-text">
          <div class="konspekt-content">


            <!-- Introduction -->
            <section id="intro">
                <h2>Вступ до частотних методів</h2>

                <p>
                    Частотні методи стеганографії (frequency domain, transform domain) працюють не з піксельними значеннями безпосередньо, а з коефіцієнтами частотних перетворень зображення. На відміну від просторових методів (LSB), частотні методи вбудовують інформацію у спектральне представлення сигналу, що забезпечує значно вищу стійкість до обробки та стиснення.
                </p>

                <div class="info-box">
                    <h4>Ключова ідея</h4>
                    <p>
                        Будь-яке зображення можна представити як суму частотних компонент — від низькочастотних (плавні переходи, фон) до високочастотних (різкі краї, текстури, шум). Частотні методи стеганографії вбудовують секретну інформацію шляхом модифікації цих компонент, обираючи коефіцієнти, зміна яких найменш помітна для людського ока.
                    </p>
                </div>

                <h3>Чому частотна область?</h3>

                <p>
                    Просторові методи (LSB) мають серйозний недолік: вони нестійкі до будь-якої обробки зображення. Навіть перезбереження у формат JPEG повністю знищує приховане повідомлення. Частотні методи вирішують цю проблему, оскільки:
                </p>

                <div class="two-columns">
                    <div>
                        <h4>Просторова область (LSB)</h4>
                        <ul>
                            <li>Працює з пікселями напряму</li>
                            <li>Висока ємність</li>
                            <li>Нестійка до стиснення</li>
                            <li>Легко детектується</li>
                            <li>Тільки BMP/PNG формати</li>
                        </ul>
                    </div>
                    <div>
                        <h4>Частотна область (DCT/DWT)</h4>
                        <ul>
                            <li>Працює зі спектром сигналу</li>
                            <li>Помірна ємність</li>
                            <li>Стійка до стиснення</li>
                            <li>Складніше детектувати</li>
                            <li>Сумісна з JPEG</li>
                        </ul>
                    </div>
                </div>

                <h3>Основні частотні перетворення</h3>

                <p>
                    У стеганографії зображень використовують три базових перетворення:
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Перетворення</th>
                        <th>Повна назва</th>
                        <th>Застосування</th>
                        <th>Формат</th>
                    </tr>
                    <tr>
                        <td><strong>DCT</strong></td>
                        <td>Discrete Cosine Transform</td>
                        <td>Основа JPEG стиснення</td>
                        <td>JPEG</td>
                    </tr>
                    <tr>
                        <td><strong>DWT</strong></td>
                        <td>Discrete Wavelet Transform</td>
                        <td>Основа JPEG 2000</td>
                        <td>JPEG 2000, будь-який</td>
                    </tr>
                    <tr>
                        <td><strong>DFT</strong></td>
                        <td>Discrete Fourier Transform</td>
                        <td>Аналіз частотного спектру</td>
                        <td>Будь-який</td>
                    </tr>
                </table>
            </section>


            <!-- DCT Methods -->
            <section id="dct">
                <h2>1. Методи на основі DCT</h2>

                <h3>1.1. Дискретне косинусне перетворення</h3>

                <p>
                    DCT (Discrete Cosine Transform) — це математичне перетворення, яке розкладає сигнал на суму косинусних функцій різних частот. У контексті зображень DCT є основою стандарту стиснення JPEG.
                </p>

                <h4>Принцип роботи DCT у JPEG</h4>

                <ol>
                    <li><strong>Поділ на блоки:</strong> зображення ділиться на блоки 8&times;8 пікселів</li>
                    <li><strong>DCT перетворення:</strong> кожен блок перетворюється з просторової області в частотну</li>
                    <li><strong>Квантування:</strong> DCT коефіцієнти діляться на матрицю квантування та округлюються</li>
                    <li><strong>Ентропійне кодування:</strong> результат стискається методом Хаффмана або арифметичним кодуванням</li>
                </ol>

                <div class="formula-box">
                    F(u,v) = (1/4) C(u) C(v) &sum;&sum; f(x,y) cos[(2x+1)u&pi;/16] cos[(2y+1)v&pi;/16]
                    <br><br>
                    де C(k) = 1/&radic;2 при k=0, C(k) = 1 інакше; x,y &isin; [0,7]; u,v &isin; [0,7]
                </div>

                <h4>Структура DCT блоку 8&times;8</h4>

                <p>
                    Після DCT перетворення блок містить 64 коефіцієнти з різним частотним значенням:
                </p>

                <ul>
                    <li><strong>DC коефіцієнт F(0,0)</strong> — середня яскравість блоку (постійна складова)</li>
                    <li><strong>Низькочастотні AC коефіцієнти</strong> — плавні переходи, основна структура</li>
                    <li><strong>Середньочастотні AC коефіцієнти</strong> — деталі, текстури</li>
                    <li><strong>Високочастотні AC коефіцієнти</strong> — різкі краї, шум</li>
                </ul>

                <div class="info-box">
                    <h4>Де вбудовувати?</h4>
                    <p>
                        Для стеганографії оптимальними є <strong>середньочастотні коефіцієнти</strong>. Низькочастотні занадто впливають на візуальну якість, а високочастотні знищуються при квантуванні (стисненні). Середньочастотні забезпечують баланс між непомітністю та стійкістю.
                    </p>
                </div>

                <h4>Квантування — ключовий етап</h4>

                <p>
                    Після DCT коефіцієнти квантуються за формулою:
                </p>

                <div class="formula-box">
                    F<sub>q</sub>(u,v) = round(F(u,v) / Q(u,v))
                </div>

                <p>
                    де Q(u,v) — матриця квантування JPEG. Стандартна матриця якості 50% має великі значення для високочастотних коефіцієнтів, що обнулює їх при квантуванні. Саме тому DCT стеганографія працює з <strong>квантованими</strong> коефіцієнтами — вони зберігаються у JPEG файлі.
                </p>

                <h3>1.2. JSteg</h3>

                <p>
                    JSteg (1998, Derek Upham) — один з перших та найпростіших DCT методів стеганографії. По суті, це LSB заміна, але для квантованих DCT коефіцієнтів замість піксельних значень.
                </p>

                <h4>Алгоритм JSteg</h4>

                <ol>
                    <li>Декодувати JPEG до рівня квантованих DCT коефіцієнтів (без повного декодування до пікселів)</li>
                    <li>Послідовно обходити ненульові AC коефіцієнти</li>
                    <li>Пропускати коефіцієнти зі значенням 0 та 1 (щоб не порушити структуру)</li>
                    <li>Замінити LSB кожного відібраного коефіцієнта на біт секретного повідомлення</li>
                    <li>Перекодувати JPEG файл із зміненими коефіцієнтами</li>
                </ol>

                <pre><code>def jsteg_embed(jpeg_data, message):
    binary_msg = text_to_binary(message)
    msg_index = 0

    for block in dct_blocks:
        for coeff in zigzag_order(block):
            if coeff == 0 or coeff == 1:
                continue  # Пропускаємо 0 та 1
            if msg_index < len(binary_msg):
                # LSB заміна DCT коефіцієнта
                coeff = (coeff & ~1) | int(binary_msg[msg_index])
                msg_index += 1

    return encode_jpeg(dct_blocks)</code></pre>

                <div class="warning-box">
                    <h4>Вразливості JSteg</h4>
                    <ul>
                        <li><strong>Chi-Square атака:</strong> аналогічна до просторового LSB, пари значень (2k, 2k+1) вирівнюються</li>
                        <li><strong>Гістограма DCT коефіцієнтів:</strong> чітко видно вирівнювання парних/непарних значень</li>
                        <li><strong>Послідовне вбудовування:</strong> дозволяє визначити довжину повідомлення</li>
                        <li>Легко виявляється інструментами <strong>stegdetect</strong> та <strong>Stegbreak</strong></li>
                    </ul>
                </div>

                <h3>1.3. OutGuess</h3>

                <p>
                    OutGuess (1999, Niels Provos) — значне покращення JSteg, яке зберігає статистичні властивості зображення після вбудовування.
                </p>

                <h4>Ключова інновація OutGuess</h4>

                <p>
                    OutGuess складається з двох фаз:
                </p>

                <ol>
                    <li><strong>Фаза вбудовування:</strong> випадковий вибір DCT коефіцієнтів (з PRNG та секретним ключем) і заміна їх LSB на біти повідомлення</li>
                    <li><strong>Фаза корекції:</strong> модифікація <em>невикористаних</em> коефіцієнтів для відновлення оригінальної гістограми DCT коефіцієнтів</li>
                </ol>

                <div class="example-box">
                    <h4>Принцип корекції гістограми</h4>
                    <p>Якщо після вбудовування кількість коефіцієнтів зі значенням 5 збільшилась на 12, а зі значенням 6 зменшилась на 12, OutGuess модифікує невикористані коефіцієнти, щоб компенсувати цей зсув. Результат: гістограма квантованих DCT коефіцієнтів стего-зображення практично ідентична оригіналу.</p>
                </div>

                <h4>Версії OutGuess</h4>

                <table class="comparison-table">
                    <tr>
                        <th>Версія</th>
                        <th>Особливості</th>
                        <th>Стійкість</th>
                    </tr>
                    <tr>
                        <td>OutGuess 0.1</td>
                        <td>Випадковий вибір коефіцієнтів, без корекції</td>
                        <td>Середня</td>
                    </tr>
                    <tr>
                        <td>OutGuess 0.2</td>
                        <td>Додано корекцію гістограми</td>
                        <td>Висока проти &chi;&sup2;-аналізу</td>
                    </tr>
                </table>

                <div class="warning-box">
                    <h4>Обмеження OutGuess</h4>
                    <p>
                        Корекція гістограми вимагає невикористаних коефіцієнтів — це обмежує ємність приблизно до 50% від доступних коефіцієнтів. Крім того, було показано, що OutGuess вразливий до атак на основі <strong>блокових артефактів</strong> та <strong>калібраційних</strong> методів (Fridrich, 2002).
                    </p>
                </div>

                <h3>1.4. F5</h3>

                <p>
                    F5 (2001, Andreas Westfeld) — один з найважливіших алгоритмів DCT стеганографії, що вводить два фундаментальних нововведення: <strong>матричне кодування</strong> та операцію <strong>декременту</strong> замість LSB заміни.
                </p>

                <h4>Еволюція DCT методів</h4>

                <p>
                    Назва F5 відображає п'яте покоління методів Вестфельда:
                </p>

                <ul>
                    <li><strong>F1:</strong> послідовне вбудовування в DCT (аналог JSteg)</li>
                    <li><strong>F2:</strong> виключення коефіцієнтів 0 та 1</li>
                    <li><strong>F3:</strong> випадковий порядок вбудовування (PRNG + ключ)</li>
                    <li><strong>F4:</strong> зміна абсолютного значення замість LSB заміни</li>
                    <li><strong>F5:</strong> матричне кодування + декремент</li>
                </ul>

                <h4>Операція декременту (F4/F5)</h4>

                <p>
                    Замість прямої LSB заміни F5 використовує зменшення абсолютного значення коефіцієнта:
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Операція</th>
                        <th>Позитивний коефіцієнт</th>
                        <th>Негативний коефіцієнт</th>
                    </tr>
                    <tr>
                        <td>Вбудовування 0</td>
                        <td>Парний |c| &rarr; без змін</td>
                        <td>Непарний |c| &rarr; без змін</td>
                    </tr>
                    <tr>
                        <td>Вбудовування 1</td>
                        <td>Непарний |c| &rarr; без змін</td>
                        <td>Парний |c| &rarr; без змін</td>
                    </tr>
                    <tr>
                        <td>Потрібна зміна</td>
                        <td>c &rarr; c &minus; 1</td>
                        <td>c &rarr; c + 1</td>
                    </tr>
                </table>

                <p>
                    Декремент зменшує абсолютне значення коефіцієнта, що природніше для квантованих DCT коефіцієнтів, ніж LSB заміна. Якщо коефіцієнт стає 0 (так зване <strong>shrinkage</strong>), він пропускається, і біт вбудовується в наступний коефіцієнт.
                </p>

                <h4>Матричне кодування (Matrix Encoding)</h4>

                <p>
                    Ключова інновація F5 — матричне кодування на основі кодів Хеммінга. Ідея: вбудовувати k біт повідомлення, змінюючи максимум <strong>один</strong> з n = 2<sup>k</sup> &minus; 1 коефіцієнтів.
                </p>

                <div class="formula-box">
                    Параметр кодування (1, n, k):
                    <br>
                    n = 2<sup>k</sup> &minus; 1 коефіцієнтів &rarr; k біт повідомлення &rarr; максимум 1 зміна
                    <br><br>
                    Ефективність вбудовування: e = k / n
                    <br>
                    Середня кількість змін на біт: R &asymp; 1/n (при рівномірному розподілі)
                </div>

                <div class="example-box">
                    <h4>Приклад: матричне кодування (1, 7, 3)</h4>
                    <p>Для вбудовування 3 біт повідомлення обираємо 7 DCT коефіцієнтів:</p>
                    <ul>
                        <li>Коефіцієнти: c<sub>1</sub>=5, c<sub>2</sub>=&minus;3, c<sub>3</sub>=2, c<sub>4</sub>=&minus;7, c<sub>5</sub>=1, c<sub>6</sub>=4, c<sub>7</sub>=&minus;2</li>
                        <li>LSB (абсолютних значень): 1, 1, 0, 1, 1, 0, 0</li>
                        <li>Синдром = LSB<sub>1</sub>&oplus;LSB<sub>3</sub>&oplus;LSB<sub>5</sub>&oplus;LSB<sub>7</sub>, LSB<sub>2</sub>&oplus;LSB<sub>3</sub>&oplus;LSB<sub>6</sub>&oplus;LSB<sub>7</sub>, LSB<sub>4</sub>&oplus;LSB<sub>5</sub>&oplus;LSB<sub>6</sub>&oplus;LSB<sub>7</sub></li>
                        <li>Якщо синдром &ne; повідомлення, змінюємо рівно один коефіцієнт за номером позиції розбіжності</li>
                    </ul>
                    <p><strong>Результат:</strong> 3 біти вбудовано з максимум 1 зміною замість 3 — зменшення спотворень у ~3 рази!</p>
                </div>

                <h4>Ємність та ефективність F5</h4>

                <table class="comparison-table">
                    <tr>
                        <th>Параметр (1,n,k)</th>
                        <th>n коефіцієнтів</th>
                        <th>k біт</th>
                        <th>Ефективність e=k/n</th>
                        <th>Змін на біт</th>
                    </tr>
                    <tr>
                        <td>(1, 1, 1)</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1.00</td>
                        <td>0.50</td>
                    </tr>
                    <tr>
                        <td>(1, 3, 2)</td>
                        <td>3</td>
                        <td>2</td>
                        <td>0.67</td>
                        <td>0.25</td>
                    </tr>
                    <tr>
                        <td>(1, 7, 3)</td>
                        <td>7</td>
                        <td>3</td>
                        <td>0.43</td>
                        <td>0.125</td>
                    </tr>
                    <tr>
                        <td>(1, 15, 4)</td>
                        <td>15</td>
                        <td>4</td>
                        <td>0.27</td>
                        <td>0.063</td>
                    </tr>
                    <tr>
                        <td>(1, 31, 5)</td>
                        <td>31</td>
                        <td>5</td>
                        <td>0.16</td>
                        <td>0.031</td>
                    </tr>
                </table>

                <div class="info-box">
                    <h4>Адаптивний вибір параметра</h4>
                    <p>
                        F5 автоматично обирає параметр k на основі кількості доступних ненульових DCT коефіцієнтів та довжини повідомлення. Чим коротше повідомлення відносно ємності контейнера, тим більше k і тим менше змін.
                    </p>
                </div>

                <div class="warning-box">
                    <h4>Вразливість F5: атака калібрацією</h4>
                    <p>
                        Фрідріх і Голян (2002) запропонували <strong>калібраційну атаку</strong>: стего-зображення обрізають на кілька пікселів та перестискують JPEG. Отримане зображення слугує оцінкою оригіналу, з яким порівнюють статистику стего-зображення. Ця атака виявляє ефект <strong>shrinkage</strong> — збільшення кількості нульових DCT коефіцієнтів після вбудовування F5.
                    </p>
                </div>

                <h3>1.5. Порівняння DCT методів</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Метод</th>
                        <th>Рік</th>
                        <th>Вбудовування</th>
                        <th>Стійкість</th>
                        <th>Ємність</th>
                    </tr>
                    <tr>
                        <td>JSteg</td>
                        <td>1998</td>
                        <td>LSB заміна DCT</td>
                        <td>Низька</td>
                        <td>Висока</td>
                    </tr>
                    <tr>
                        <td>OutGuess 0.2</td>
                        <td>1999</td>
                        <td>LSB + корекція гістограми</td>
                        <td>Середня</td>
                        <td>Середня</td>
                    </tr>
                    <tr>
                        <td>F5</td>
                        <td>2001</td>
                        <td>Декремент + матричне кодування</td>
                        <td>Висока</td>
                        <td>Адаптивна</td>
                    </tr>
                    <tr>
                        <td>nsF5</td>
                        <td>2007</td>
                        <td>F5 без shrinkage</td>
                        <td>Дуже висока</td>
                        <td>Адаптивна</td>
                    </tr>
                </table>
            </section>


            <!-- DWT Methods -->
            <section id="dwt">
                <h2>2. Методи на основі DWT</h2>

                <h3>2.1. Дискретне вейвлет-перетворення</h3>

                <p>
                    DWT (Discrete Wavelet Transform) — це математичне перетворення, що розкладає сигнал на компоненти різного масштабу та просторового розташування. На відміну від DCT, яке працює з блоками фіксованого розміру, DWT забезпечує <strong>багатомасштабний аналіз</strong> (multiresolution analysis), який краще відповідає структурі природних зображень.
                </p>

                <h4>Принцип вейвлет-декомпозиції</h4>

                <p>
                    Одна ітерація DWT розкладає зображення на чотири суб-смуги (subbands):
                </p>

                <table class="comparison-table">
                    <tr>
                        <th>Суб-смуга</th>
                        <th>Фільтрація</th>
                        <th>Зміст</th>
                        <th>Енергія</th>
                    </tr>
                    <tr>
                        <td><strong>LL</strong> (Low-Low)</td>
                        <td>Низькочастотна по обох осях</td>
                        <td>Апроксимація зображення (зменшена копія)</td>
                        <td>~95% від загальної</td>
                    </tr>
                    <tr>
                        <td><strong>LH</strong> (Low-High)</td>
                        <td>Низька по горизонталі, висока по вертикалі</td>
                        <td>Горизонтальні деталі (краї)</td>
                        <td>~2%</td>
                    </tr>
                    <tr>
                        <td><strong>HL</strong> (High-Low)</td>
                        <td>Висока по горизонталі, низька по вертикалі</td>
                        <td>Вертикальні деталі (краї)</td>
                        <td>~2%</td>
                    </tr>
                    <tr>
                        <td><strong>HH</strong> (High-High)</td>
                        <td>Високочастотна по обох осях</td>
                        <td>Діагональні деталі, шум</td>
                        <td>~1%</td>
                    </tr>
                </table>

                <p>
                    Декомпозицію можна повторити для LL суб-смуги, отримуючи <strong>багаторівневу</strong> структуру. Типово використовують 2&ndash;4 рівні декомпозиції.
                </p>

                <h4>Типи вейвлетів</h4>

                <p>
                    Найпоширеніші сімейства вейвлетів у стеганографії:
                </p>

                <ul>
                    <li><strong>Haar</strong> — найпростіший вейвлет, швидкий, але грубий</li>
                    <li><strong>Daubechies (db1&ndash;db10)</strong> — компактні, гарне частотне розділення</li>
                    <li><strong>Biorthogonal (bior)</strong> — симетричні, використовуються у JPEG 2000</li>
                    <li><strong>Coiflet</strong> — наближені до симетричних, високі моменти обнулення</li>
                </ul>

                <h3>2.2. Стратегії вбудовування у DWT</h3>

                <h4>Стратегія 1: Вбудовування в деталізуючі суб-смуги (LH, HL, HH)</h4>

                <p>
                    Найпоширеніший підхід — модифікувати коефіцієнти деталізуючих суб-смуг, оскільки вони містять менше візуально значущої інформації:
                </p>

                <pre><code>def dwt_embed_detail(image, message, strength=0.1):
    coeffs = pywt.dwt2(image, 'haar')
    LL, (LH, HL, HH) = coeffs

    binary_msg = text_to_binary(message)

    # Вбудовування в LH суб-смугу
    for i, bit in enumerate(binary_msg):
        row, col = index_to_position(i, LH.shape)
        if int(bit) == 1:
            LH[row, col] += strength
        else:
            LH[row, col] -= strength

    return pywt.idwt2((LL, (LH, HL, HH)), 'haar')</code></pre>

                <h4>Стратегія 2: Вбудовування у LL суб-смугу</h4>

                <p>
                    Модифікація LL коефіцієнтів забезпечує <strong>вищу стійкість</strong> до обробки (стиснення, фільтрації), оскільки LL містить основну енергію зображення. Проте потребує меншої амплітуди зміни, щоб залишатися непомітною.
                </p>

                <h4>Стратегія 3: Адаптивне вбудовування</h4>

                <p>
                    Використання локальної складності зображення для визначення сили вбудовування:
                </p>

                <ul>
                    <li>У текстурованих ділянках (високі коефіцієнти деталей) — більша амплітуда</li>
                    <li>У гладких ділянках (низькі коефіцієнти) — менша амплітуда або пропуск</li>
                </ul>

                <h3>2.3. Переваги DWT над DCT</h3>

                <div class="two-columns">
                    <div>
                        <h4>DCT</h4>
                        <ul>
                            <li>Блокова обробка 8&times;8</li>
                            <li>Блокові артефакти</li>
                            <li>Одна роздільна здатність</li>
                            <li>Стандарт JPEG</li>
                        </ul>
                    </div>
                    <div>
                        <h4>DWT</h4>
                        <ul>
                            <li>Обробка всього зображення</li>
                            <li>Без блокових артефактів</li>
                            <li>Багатомасштабний аналіз</li>
                            <li>Стандарт JPEG 2000</li>
                        </ul>
                    </div>
                </div>

                <div class="info-box">
                    <h4>Практичне значення DWT</h4>
                    <p>
                        DWT-методи особливо ефективні для <strong>цифрових водяних знаків</strong>, де стійкість до обробки критично важлива. Для стеганографії DWT забезпечує кращу адаптацію до локальних особливостей зображення завдяки просторово-частотній локалізації вейвлетів.
                    </p>
                </div>

                <h3>2.4. Метрики якості для DWT стеганографії</h3>

                <p>
                    Якість DWT стеганографії оцінюють тими ж метриками, що й просторові методи (PSNR, SSIM), але додатково використовують:
                </p>

                <ul>
                    <li><strong>NC (Normalized Correlation)</strong> — кореляція між вбудованим та витягнутим повідомленням, NC = 1 означає ідеальне витягування</li>
                    <li><strong>BER (Bit Error Rate)</strong> — частка помилково витягнутих бітів після обробки зображення</li>
                    <li><strong>Robustness Factor</strong> — NC або BER після серії атак (стиснення, фільтрація, шум)</li>
                </ul>
            </section>


            <!-- Spread Spectrum -->
            <section id="spread-spectrum">
                <h2>3. Методи розширення спектру</h2>

                <h3>3.1. Принцип розширення спектру</h3>

                <p>
                    Spread Spectrum (SS) стеганографія запозичує ідеї з військових систем зв'язку. Основний принцип: замість концентрації прихованої інформації у вузькій смузі частот, вона <strong>розподіляється по всьому спектру</strong> сигналу з низькою амплітудою, що робить її подібною до шуму та стійкою до атак.
                </p>

                <div class="info-box">
                    <h4>Аналогія</h4>
                    <p>
                        Уявіть розмову в шумному залі. LSB — це як говорити пошепки одному слухачу (ефективно, але будь-хто поруч почує). Spread Spectrum — як розподілити слова серед сотні людей, кожен з яких знає лише одну букву (ніхто окремо не може зрозуміти повідомлення, а разом — лише той, хто знає ключ).
                    </p>
                </div>

                <h4>Формальна модель</h4>

                <p>
                    У найпростішому вигляді SS стеганографія описується формулою:
                </p>

                <div class="formula-box">
                    s = c + &alpha; &middot; w
                    <br><br>
                    де s — стего-зображення, c — контейнер (cover), w — сигнал водяного знаку/повідомлення, &alpha; — коефіцієнт сили вбудовування
                </div>

                <p>
                    Сигнал w генерується як псевдовипадкова послідовність (PN-послідовність) довжиною, рівною розміру контейнера, модульована бітами повідомлення.
                </p>

                <h3>3.2. DSSS (Direct Sequence Spread Spectrum)</h3>

                <p>
                    DSSS — найпоширеніший метод SS стеганографії. Кожен біт повідомлення множиться на довгу PN-послідовність (чіп-послідовність) та додається до контейнера.
                </p>

                <h4>Алгоритм вбудовування DSSS</h4>

                <ol>
                    <li>Згенерувати PN-послідовність p довжиною L за секретним ключем</li>
                    <li>Для кожного біта b повідомлення:
                        <ul>
                            <li>Якщо b = 1: додати +&alpha; &middot; p до відповідного сегменту зображення</li>
                            <li>Якщо b = 0: додати &minus;&alpha; &middot; p до відповідного сегменту зображення</li>
                        </ul>
                    </li>
                </ol>

                <pre><code>def dsss_embed(image, message, key, alpha=0.1, chip_length=1000):
    prng = PRNG(key)
    flat_image = image.flatten().astype(float)

    for i, bit in enumerate(message):
        # Генерація чіп-послідовності для цього біта
        chip = prng.randn(chip_length)
        chip = chip / np.linalg.norm(chip)  # Нормалізація

        start = i * chip_length
        segment = flat_image[start : start + chip_length]

        # Вбудовування
        sign = 1 if bit == '1' else -1
        segment += alpha * sign * chip

    return flat_image.reshape(image.shape)</code></pre>

                <h4>Кореляційне детектування</h4>

                <p>
                    Витягування повідомлення базується на обчисленні <strong>кореляції</strong> між отриманим сигналом та відомою PN-послідовністю:
                </p>

                <div class="formula-box">
                    r = (1/L) &sum;<sub>j=1</sub><sup>L</sup> s<sub>j</sub> &middot; p<sub>j</sub>
                    <br><br>
                    Рішення: якщо r &gt; 0, витягнутий біт = 1; якщо r &lt; 0, витягнутий біт = 0
                </div>

                <p>
                    Чим довша чіп-послідовність L (processing gain), тим надійніше детектування, але менша ємність. Це класичний компроміс між стійкістю та ємністю.
                </p>

                <div class="example-box">
                    <h4>Приклад: вплив processing gain</h4>
                    <p>Для зображення 512&times;512 = 262,144 пікселів:</p>
                    <table class="comparison-table">
                        <tr>
                            <th>Chip length (L)</th>
                            <th>Ємність</th>
                            <th>Processing gain</th>
                            <th>Стійкість</th>
                        </tr>
                        <tr>
                            <td>100</td>
                            <td>2,621 біт</td>
                            <td>20 dB</td>
                            <td>Низька</td>
                        </tr>
                        <tr>
                            <td>1,000</td>
                            <td>262 біти</td>
                            <td>30 dB</td>
                            <td>Середня</td>
                        </tr>
                        <tr>
                            <td>10,000</td>
                            <td>26 біт</td>
                            <td>40 dB</td>
                            <td>Висока</td>
                        </tr>
                    </table>
                </div>

                <h3>3.3. FHSS (Frequency Hopping Spread Spectrum)</h3>

                <p>
                    У FHSS кожен біт повідомлення вбудовується у <strong>різні частотні діапазони</strong>, що змінюються відповідно до псевдовипадкової послідовності. Це забезпечує додатковий захист від вузькосмугових атак.
                </p>

                <h4>Принцип FHSS</h4>

                <ol>
                    <li>Розділити частотний спектр зображення на N піддіапазонів</li>
                    <li>Згенерувати послідовність вибору діапазонів за секретним ключем</li>
                    <li>Для кожного біта вбудовувати інформацію у відповідний піддіапазон</li>
                    <li>Перейти до наступного діапазону ("стрибок" частоти)</li>
                </ol>

                <div class="info-box">
                    <h4>DSSS vs FHSS</h4>
                    <p>
                        <strong>DSSS</strong> використовує весь спектр одночасно з низькою амплітудою. <strong>FHSS</strong> використовує вузькі смуги послідовно, але з вищою амплітудою в кожній. DSSS забезпечує кращу стійкість, FHSS — кращий захист від виявлення.
                    </p>
                </div>

                <h3>3.4. Переваги та недоліки SS методів</h3>

                <div class="two-columns">
                    <div>
                        <h4>Переваги</h4>
                        <ul>
                            <li>Висока стійкість до обробки</li>
                            <li>Стійкість до геометричних атак</li>
                            <li>Важко виявити (подібне до шуму)</li>
                            <li>Не потребує оригіналу для витягування</li>
                        </ul>
                    </div>
                    <div>
                        <h4>Недоліки</h4>
                        <ul>
                            <li>Дуже низька ємність</li>
                            <li>Потребує синхронізації</li>
                            <li>Високі обчислювальні витрати</li>
                            <li>Складне налаштування параметрів</li>
                        </ul>
                    </div>
                </div>
            </section>


            <!-- QIM -->
            <section id="qim">
                <h2>4. Квантова індексна модуляція (QIM)</h2>

                <h3>4.1. Принципи квантування</h3>

                <p>
                    QIM (Quantization Index Modulation), запропонована Ченом та Ворнеллом у 2001 році, — це принципово інший підхід до стеганографії. Замість <strong>адитивного</strong> вбудовування (додавання сигналу, як у SS), QIM використовує <strong>квантування</strong>: значення контейнера квантуються до різних наборів рівнів залежно від біта повідомлення.
                </p>

                <div class="info-box">
                    <h4>Ключова ідея QIM</h4>
                    <p>
                        Створюємо два набори рівнів квантування: &Lambda;<sub>0</sub> для вбудовування біта 0 та &Lambda;<sub>1</sub> для вбудовування біта 1. Значення контейнера квантується до найближчого рівня з набору, який відповідає біту повідомлення. При витягуванні визначаємо, до якого набору ближче отримане значення.
                    </p>
                </div>

                <h4>Формальне визначення</h4>

                <div class="formula-box">
                    Вбудовування: s = Q<sub>m</sub>(c), де m &isin; {0, 1} — біт повідомлення
                    <br><br>
                    Q<sub>m</sub>(c) = &Delta; &middot; round((c &minus; d<sub>m</sub>) / &Delta;) + d<sub>m</sub>
                    <br><br>
                    Витягування: m&#x0302; = argmin<sub>m</sub> |s &minus; Q<sub>m</sub>(s)|
                </div>

                <p>
                    де &Delta; — крок квантування, d<sub>m</sub> — зсув для біта m. Типово d<sub>0</sub> = 0, d<sub>1</sub> = &Delta;/2.
                </p>

                <h3>4.2. Scalar QIM (базовий варіант)</h3>

                <p>
                    У найпростішому скалярному QIM два набори квантування зміщені на &Delta;/2:
                </p>

                <ul>
                    <li><strong>&Lambda;<sub>0</sub>:</strong> {..., &minus;&Delta;, 0, &Delta;, 2&Delta;, ...}</li>
                    <li><strong>&Lambda;<sub>1</sub>:</strong> {..., &minus;&Delta;/2, &Delta;/2, 3&Delta;/2, ...}</li>
                </ul>

                <div class="example-box">
                    <h4>Приклад скалярного QIM</h4>
                    <p>Нехай &Delta; = 10, значення пікселя c = 47:</p>
                    <ul>
                        <li><strong>Вбудовування 0:</strong> Q<sub>0</sub>(47) = 10 &middot; round(47/10) = 50</li>
                        <li><strong>Вбудовування 1:</strong> Q<sub>1</sub>(47) = 10 &middot; round((47&minus;5)/10) + 5 = 45</li>
                    </ul>
                    <p>Максимальне спотворення: &Delta;/2 = 5</p>
                    <p><strong>Витягування:</strong> отримали значення 45. Відстань до &Lambda;<sub>0</sub> (50): 5. Відстань до &Lambda;<sub>1</sub> (45): 0. Витягнутий біт = 1.</p>
                </div>

                <h3>4.3. DC-QIM (Distortion Compensated QIM)</h3>

                <p>
                    DC-QIM (Dither Compensated QIM, або Distortion Compensated QIM) — вдосконалена версія, яка зменшує спотворення шляхом часткової компенсації:
                </p>

                <div class="formula-box">
                    s = c + &lambda; &middot; (Q<sub>m</sub>(c) &minus; c)
                    <br><br>
                    де &lambda; &isin; (0, 1] — коефіцієнт компенсації
                </div>

                <p>
                    При &lambda; = 1 отримуємо звичайний QIM. При &lambda; &lt; 1 зменшуємо спотворення, але також зменшуємо стійкість до шуму. Оптимальне значення &lambda; залежить від очікуваного рівня шуму каналу.
                </p>

                <h3>4.4. Dither Modulation</h3>

                <p>
                    Dither Modulation — варіант QIM, де набори квантування зміщуються за допомогою <strong>секретної dither послідовності</strong>, що забезпечує додатковий рівень безпеки:
                </p>

                <div class="formula-box">
                    s = Q<sub>m</sub>(c + d) &minus; d
                    <br><br>
                    де d — елемент секретної dither послідовності, рівномірно розподілений на [&minus;&Delta;/2, &Delta;/2]
                </div>

                <p>
                    Без знання dither послідовності неможливо визначити, до якого набору квантування належить значення — це забезпечує безпеку, аналогічну використанню ключа шифрування.
                </p>

                <h3>4.5. QIM vs інші методи</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Характеристика</th>
                        <th>LSB</th>
                        <th>Spread Spectrum</th>
                        <th>QIM</th>
                    </tr>
                    <tr>
                        <td><strong>Принцип</strong></td>
                        <td>Заміна бітів</td>
                        <td>Адитивне вбудовування</td>
                        <td>Квантування</td>
                    </tr>
                    <tr>
                        <td><strong>Ємність</strong></td>
                        <td>Висока</td>
                        <td>Низька</td>
                        <td>Середня</td>
                    </tr>
                    <tr>
                        <td><strong>Стійкість</strong></td>
                        <td>Низька</td>
                        <td>Висока</td>
                        <td>Середня-Висока</td>
                    </tr>
                    <tr>
                        <td><strong>Непомітність</strong></td>
                        <td>Висока (низький BPP)</td>
                        <td>Висока</td>
                        <td>Залежить від &Delta;</td>
                    </tr>
                    <tr>
                        <td><strong>Потрібен оригінал?</strong></td>
                        <td>Ні</td>
                        <td>Залежно від реалізації</td>
                        <td>Ні</td>
                    </tr>
                    <tr>
                        <td><strong>Теоретичний оптимум</strong></td>
                        <td>Ні</td>
                        <td>Ні</td>
                        <td>Так (Costa, 1983)</td>
                    </tr>
                </table>

                <div class="info-box">
                    <h4>Теорема Коста (Costa's Writing on Dirty Paper)</h4>
                    <p>
                        QIM наближається до теоретичного оптимуму, описаного теоремою Коста (1983): якщо вбудовувач знає контейнер (cover), він може досягти ємності каналу, що не залежить від потужності сигналу контейнера. Іншими словами, наявність контейнера не є перешкодою, а ресурсом — як чисте "брудне" полотно для письма.
                    </p>
                </div>
            </section>


            <!-- Practice -->
            <section id="practice">
                <h2>5. Практичні аспекти та порівняння</h2>

                <h3>5.1. Вибір методу для конкретної задачі</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Задача</th>
                        <th>Рекомендований метод</th>
                        <th>Обґрунтування</th>
                    </tr>
                    <tr>
                        <td>Таємна комунікація через JPEG</td>
                        <td>nsF5, адаптивний F5</td>
                        <td>Висока непомітність, матричне кодування</td>
                    </tr>
                    <tr>
                        <td>Захист авторських прав</td>
                        <td>DWT + SS</td>
                        <td>Максимальна стійкість до обробки</td>
                    </tr>
                    <tr>
                        <td>Перевірка цілісності</td>
                        <td>DCT-QIM</td>
                        <td>Баланс стійкості та ємності</td>
                    </tr>
                    <tr>
                        <td>Високоємна стеганографія</td>
                        <td>DWT деталізуючі суб-смуги</td>
                        <td>Ємність вища за DCT при збереженні якості</td>
                    </tr>
                    <tr>
                        <td>Стійкість до геометричних атак</td>
                        <td>DFT + SS</td>
                        <td>Інваріантність DFT до обертання/масштабування</td>
                    </tr>
                </table>

                <h3>5.2. Типові параметри якості</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Метод</th>
                        <th>PSNR (dB)</th>
                        <th>SSIM</th>
                        <th>BPP</th>
                        <th>Стійкість до JPEG 75%</th>
                    </tr>
                    <tr>
                        <td>JSteg</td>
                        <td>38&ndash;42</td>
                        <td>0.97&ndash;0.99</td>
                        <td>0.05&ndash;0.15</td>
                        <td>Повна (працює з JPEG)</td>
                    </tr>
                    <tr>
                        <td>F5 (1,7,3)</td>
                        <td>40&ndash;45</td>
                        <td>0.98&ndash;0.99</td>
                        <td>0.03&ndash;0.10</td>
                        <td>Повна</td>
                    </tr>
                    <tr>
                        <td>DWT-LH</td>
                        <td>42&ndash;50</td>
                        <td>0.98&ndash;0.99</td>
                        <td>0.05&ndash;0.20</td>
                        <td>Часткова (BER &lt; 5%)</td>
                    </tr>
                    <tr>
                        <td>DSSS</td>
                        <td>35&ndash;45</td>
                        <td>0.95&ndash;0.99</td>
                        <td>0.001&ndash;0.01</td>
                        <td>Висока (BER &lt; 1%)</td>
                    </tr>
                    <tr>
                        <td>QIM (&Delta;=10)</td>
                        <td>38&ndash;44</td>
                        <td>0.97&ndash;0.99</td>
                        <td>0.03&ndash;0.10</td>
                        <td>Середня (BER &lt; 10%)</td>
                    </tr>
                </table>

                <h3>5.3. Стегоаналіз частотних методів</h3>

                <p>
                    Кожен метод має характерні "відбитки", що використовуються для стегоаналізу:
                </p>

                <ul>
                    <li><strong>JSteg:</strong> Chi-Square аналіз гістограми DCT коефіцієнтів, вирівнювання пар значень</li>
                    <li><strong>OutGuess:</strong> калібраційна атака (crop + recompress), аналіз блокових артефактів</li>
                    <li><strong>F5:</strong> калібрація + аналіз shrinkage (збільшення нулів у DCT), атака Фрідріх</li>
                    <li><strong>DWT методи:</strong> аналіз статистики вейвлет-коефіцієнтів (розподіл Лапласа), порушення міжсмугових кореляцій</li>
                    <li><strong>SS методи:</strong> аналіз гаусовості шуму, тест на стаціонарність, кореляційні атаки при відомій PN-послідовності</li>
                    <li><strong>QIM:</strong> аналіз квантувальних артефактів, розподіл помилок квантування</li>
                </ul>

                <h3>5.4. Інструменти для частотної стеганографії</h3>

                <table class="comparison-table">
                    <tr>
                        <th>Інструмент</th>
                        <th>Метод</th>
                        <th>Формат</th>
                        <th>Ліцензія</th>
                    </tr>
                    <tr>
                        <td><strong>F5 (Java)</strong></td>
                        <td>F5 матричне кодування</td>
                        <td>JPEG</td>
                        <td>Open source</td>
                    </tr>
                    <tr>
                        <td><strong>OutGuess</strong></td>
                        <td>OutGuess 0.2</td>
                        <td>JPEG, PNM</td>
                        <td>Open source</td>
                    </tr>
                    <tr>
                        <td><strong>nsF5</strong></td>
                        <td>F5 без shrinkage</td>
                        <td>JPEG</td>
                        <td>Дослідницький</td>
                    </tr>
                    <tr>
                        <td><strong>StirMark</strong></td>
                        <td>Тестування стійкості</td>
                        <td>Різні</td>
                        <td>Open source</td>
                    </tr>
                    <tr>
                        <td><strong>stegdetect</strong></td>
                        <td>Виявлення JSteg/OutGuess/F5</td>
                        <td>JPEG</td>
                        <td>Open source</td>
                    </tr>
                </table>
            </section>


            <!-- Conclusion -->
            <section id="conclusion">
                <h2>Висновки</h2>

                <h3>Ключові моменти лекції</h3>

                <ul>
                    <li><strong>Частотні методи</strong> працюють зі спектральним представленням сигналу, забезпечуючи вищу стійкість за просторові</li>
                    <li><strong>DCT методи</strong> (JSteg, OutGuess, F5) — основа стеганографії у JPEG; F5 з матричним кодуванням мінімізує кількість змін</li>
                    <li><strong>DWT методи</strong> — багатомасштабний аналіз, відсутність блокових артефактів, ефективна адаптація до вмісту</li>
                    <li><strong>Spread Spectrum</strong> — максимальна стійкість за рахунок дуже низької ємності; ідеальний для водяних знаків</li>
                    <li><strong>QIM</strong> — теоретично оптимальний підхід на основі квантування, наближається до границі Коста</li>
                </ul>

                <h3>Еволюція стеганографічних методів</h3>

                <div class="info-box">
                    <h4>Від простого до складного</h4>
                    <p>
                        Розвиток стеганографії зображень можна простежити як ланцюг: <strong>просторовий LSB</strong> &rarr; <strong>DCT LSB (JSteg)</strong> &rarr; <strong>DCT з корекцією (OutGuess)</strong> &rarr; <strong>матричне кодування (F5)</strong> &rarr; <strong>адаптивні методи (HUGO, WOW, S-UNIWARD)</strong>. Кожен наступний крок зменшує статистичні аномалії, ускладнюючи стегоаналіз.
                    </p>
                </div>

                <div class="info-box">
                    <h4>Що далі?</h4>
                    <p>
                        У наступній лекції ми розглянемо <strong>адаптивні методи стеганографії</strong> — HUGO, WOW, S-UNIWARD, які поєднують частотний аналіз з оптимізацією вбудовування на основі локальної складності зображення. Ці методи є сучасним стандартом стеганографії та найскладнішими для виявлення.
                    </p>
                </div>
            </section>


          </div>
        </div>
      <aside class="konspekt-sidebar">
        <div class="section-nav">
          <h4>Зміст</h4>
          <ul>
          <li><a href="#intro">Вступ</a></li>
          <li><a href="#dct">1. Методи на основі DCT</a></li>
          <li><a href="#dwt">2. Методи на основі DWT</a></li>
          <li><a href="#spread-spectrum">3. Розширення спектру</a></li>
          <li><a href="#qim">4. QIM</a></li>
          <li><a href="#practice">5. Практика</a></li>
          <li><a href="#conclusion">Висновки</a></li>
          </ul>
        </div>
      </aside>
      </div>
    </article>

    <div class="lecture-nav-bottom">
      <a href="../lecture.html?id=6" class="nav-btn">&larr; До лекції</a>
      <a href="../index.html" class="nav-btn">На головну &rarr;</a>
    </div>

    <footer></footer>
  </main>

  <button class="back-to-top">&#8593;</button>

  <script src="../js/main.js"></script>
  <script>
    // Reading Progress Bar
    window.addEventListener('scroll', () => {
      const docHeight = document.documentElement.scrollHeight - window.innerHeight;
      const scrolled = (window.scrollY / docHeight) * 100;
      document.querySelector('.reading-progress-bar').style.width = scrolled + '%';
      const backToTop = document.querySelector('.back-to-top');
      if (window.scrollY > 300) { backToTop.classList.add('show'); }
      else { backToTop.classList.remove('show'); }
    });

    // Active section nav link
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.section-nav a');
    if (navLinks.length > 0) {
      window.addEventListener('scroll', () => {
        let current = '';
        sections.forEach(section => {
          if (scrollY >= section.offsetTop - 200) {
            current = section.getAttribute('id');
          }
        });
        navLinks.forEach(link => {
          link.classList.remove('active');
          if (link.getAttribute('href') === '#' + current) {
            link.classList.add('active');
          }
        });
      });
    }
  </script>
</body>
</html>
